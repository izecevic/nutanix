{
  "status": {
    "description": "Provisions a Karbon K8s cluster and enables worker node addition and removal.",
    "state": "ACTIVE",
    "message_list": [],
    "resources": {
      "service_definition_list": [
        {
          "port_list": [],
          "description": "",
          "action_list": [
            {
              "description": "System action for creating an application",
              "message_list": [],
              "uuid": "da815726-5ff4-4423-a16b-93c9608c8395",
              "name": "action_create",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "62f3f78b-6bc2-4be4-a7ae-8bdd98ef2c04",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=PcGetProjectReference; uuid=577fed82-5c70-4fd7-86b6-479c78230ca1}",
                      "@{kind=app_task; name=PcCheckProjectQuota; uuid=d22110e9-1589-4fc4-8e5c-254e35721c56}",
                      "@{kind=app_task; name=KarbonCreateCluster; uuid=0614ebf8-0a32-45fb-9fbf-dc386ea678dd}",
                      "@{kind=app_task; name=KarbonGetClusterHealth; uuid=2d422db8-8dd8-4a18-953d-bdd42a9c6408}",
                      "@{kind=app_task; name=KarbonGetClusterDetails; uuid=20f5f5ec-589a-4434-85eb-2ffda068fa05}",
                      "@{kind=app_task; name=UpdateVmProject; uuid=fb6162f4-4afa-4988-abf6-564709c1b14d}",
                      "@{kind=app_task; name=SendKubeconfig; uuid=15a67ab3-fabb-4558-a4d3-a7332239c311}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "      ",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "e1584237_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SET_VARIABLE",
                    "uuid": "577fed82-5c70-4fd7-86b6-479c78230ca1",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220111\n# task_name:    PcGetProjectReference\n# description:  Given a project name, get the project reference metadata section. \n#               This is then meant to be used to update a VM project reference to move \n#               that VM into the project.\n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   project_reference (as json output)\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_name = \"@@{calm_project_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_projects(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of Projects from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of Projects (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/projects/list\"\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"project\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"project\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n\ndef prism_get_project(api_server,username,secret,project_name,project_uuid=None,secure=False):\n    \"\"\"Returns from Prism Central the uuid and details of a given project name.\n       If a project_uuid is specified, it will skip retrieving all vms (faster).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        project_name: Name of the project.\n        project_uuid: Uuid of the project (optional).\n        \n    Returns:\n        A string containing the UUID of the Project (project_uuid) and the json content\n        of the project details (project_details)\n    \"\"\"\n    project_details = {}\n\n    if project_uuid is None:\n        #get the list vms from Prism\n        project_list = prism_get_projects(api_server,username,secret,secure)\n        for project in project_list:\n            if project['spec']['name'] == project_name:\n                project_uuid = project['metadata']['uuid']\n                project_details = project.copy()\n                break\n    else:\n        headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n        }\n        api_server_port = \"9440\"\n        api_server_endpoint = \"/api/nutanix/v3/projects/{0}\".format(project_uuid)\n        url = \"https://{}:{}{}\".format(\n            api_server,\n            api_server_port,\n            api_server_endpoint\n        )\n        method = \"GET\"\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,secure)\n        if resp.ok:\n            project_details = json.loads(resp.content)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n    return project_uuid, project_details\n\n#endregion functions\n\n\n#region main execution\nproject_uuid,project_details = prism_get_project(prism_central_ip,pc_user,pc_password,project_name)\nproject_reference = project_details['metadata']['project_reference']\nprint(\"project_reference={}\".format(json.dumps(project_reference)))\nexit(0)\n#endregion main execution\n",
                      "eval_variables": "project_reference",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "PcGetProjectReference"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "d22110e9-1589-4fc4-8e5c-254e35721c56",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220111\n# task_name:    PcCheckProjectQuota\n# description:  Given a project name, check the project quota against provided resources. \n#               If there are not enough available resources in the quota, returns a failure code.\n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_reference = json.loads('@@{project_reference}@@')\nmaster_config = \"@@{master_config}@@\"\nworker_node_cpu_count = int(\"@@{worker_node_cpu}@@\")\nworker_node_vram_bytes = int(\"@@{worker_node_memory}@@\")*1024*1024*1024\nworker_node_storage_bytes = (int(\"@@{worker_node_disk_size}@@\")+40)*1024*1024*1024\nworker_node_qty = int(\"@@{worker_node_qty}@@\")\n\n#? master and etcd nodes configuration depends on master_config (Single Master, or Active-Passive/Active-Active)\n#? worker nodes is based on user input and stored in worker_node_cpu, worker_node_memory, worker_node_disk_size, worker_node_qty\n#? for disk size, add +40GB for system disks for each node VM\nif master_config == \"Single Master\":\n    master_node_cpu_count = 2\n    master_node_vram_bytes = 4*1024*1024*1024\n    master_node_storage_bytes = (120+40)*1024*1024*1024\n    master_node_qty = 1\n    etcd_node_cpu_count = 4\n    etcd_node_vram_bytes = 8*1024*1024*1024\n    etcd_node_storage_bytes = (40+40)*1024*1024*1024\n    etcd_node_qty = 1\nelse:\n    master_node_cpu_count = 4\n    master_node_vram_bytes = 4*1024*1024*1024\n    master_node_storage_bytes = (120+40)*1024*1024*1024\n    master_node_qty = 2\n    etcd_node_cpu_count = 4\n    etcd_node_vram_bytes = 8*1024*1024*1024\n    etcd_node_storage_bytes = (40+40)*1024*1024*1024\n    etcd_node_qty = 3\n\n#worker node(s) + master node(s) + etcd node(s) \nrequired_vcpus_count = (int(worker_node_cpu_count) * int(worker_node_qty)) + (master_node_cpu_count * master_node_qty) +  (etcd_node_cpu_count * etcd_node_qty)\nrequired_vram_bytes = (int(worker_node_vram_bytes) * int(worker_node_qty)) + (master_node_vram_bytes * master_node_qty) +  (etcd_node_vram_bytes * etcd_node_qty)\nrequired_storage_bytes = (int(worker_node_storage_bytes) * int(worker_node_qty)) + (master_node_storage_bytes * master_node_qty) +  (etcd_node_storage_bytes * etcd_node_qty)\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_projects(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of Projects from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of Projects (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/projects/list\"\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"project\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"project\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n\ndef prism_get_project(api_server,username,secret,project_name=None,project_uuid=None,secure=False):\n    \"\"\"Returns from Prism Central the uuid and details of a given project name.\n       If a project_uuid is specified, it will skip retrieving all vms (faster).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        project_name: Name of the project.\n        project_uuid: Uuid of the project (optional).\n        \n    Returns:\n        A string containing the UUID of the Project (project_uuid) and the json content\n        of the project details (project_details)\n    \"\"\"\n    project_details = {}\n\n    if project_uuid is None:\n        #get the list vms from Prism\n        project_list = prism_get_projects(api_server,username,secret,secure)\n        for project in project_list:\n            if project['spec']['name'] == project_name:\n                project_uuid = project['metadata']['uuid']\n                project_details = project.copy()\n                break\n    else:\n        headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n        }\n        api_server_port = \"9440\"\n        api_server_endpoint = \"/api/nutanix/v3/projects/{0}\".format(project_uuid)\n        url = \"https://{}:{}{}\".format(\n            api_server,\n            api_server_port,\n            api_server_endpoint\n        )\n        method = \"GET\"\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,secure)\n        if resp.ok:\n            project_details = json.loads(resp.content)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n    return project_uuid, project_details\n\n#endregion functions\n\n\n#region main execution\n\nprint(\"Provisioning request required vCPUs: {}\".format(required_vcpus_count))\nprint(\"Provisioning request required memory GB: {}\".format(required_vram_bytes/1024/1024/1024))\nprint(\"Provisioning request required storage GB: {}\".format(required_storage_bytes/1024/1024/1024))\n\n\n#region get project quotas\nproject_uuid,project_details = prism_get_project(prism_central_ip,pc_user,pc_password,project_uuid=project_reference['uuid'])\n#get resource total allocated quota from the project definition\nproject_cpu_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'VCPUS']\nprint(\"Project vCPU quota: {}\".format(project_cpu_quota[0]))\nproject_memory_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'MEMORY']\nprint(\"Project memory GB quota: {}\".format(int(project_memory_bytes_quota[0])/1024/1024/1024))\nproject_storage_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'STORAGE']\nprint(\"Project storage GB quota: {}\".format(int(project_storage_bytes_quota[0])/1024/1024/1024))\n#endregion get project quotas\n\n#region get project allocated resources\n#retrieve list of project vms and their current resource allocation\n#region api call\nheaders = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n}\napi_server_port = \"9440\"\napi_server_endpoint = \"/api/nutanix/v3/groups\"\nurl = \"https://{}:{}{}\".format(\n    prism_central_ip,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\npayload = {\n    \"entity_type\": \"mh_vm\",\n    \"group_member_count\": 500,\n    \"group_member_offset\": 0,\n    \"group_member_attributes\": [\n        {\n            \"attribute\": \"memory_size_bytes\"\n        },\n        {\n            \"attribute\": \"capacity_bytes\"\n        },\n        {\n            \"attribute\": \"num_vcpus\"\n        },\n        {\n            \"attribute\": \"project_reference\"\n        },\n        {\n            \"attribute\": \"project_name\"\n        }\n    ],\n    \"query_name\": \"prism:EBQueryModel\",\n    \"availability_zone_scope\": \"GLOBAL\",\n    \"filter_criteria\": \"(platform_type!=aws,platform_type==[no_val]);project_reference=in={}\".format(project_uuid)\n}\nprint(\"Making a {} API call to {}\".format(method, url))\nr = process_request(url,method,pc_user,pc_password,headers,payload)\n#endregion api call\n\n#compute total current resource allocation\nresp = json.loads(r.content)\n\n\nproject_cpu_allocated = 0\nproject_memory_bytes_allocated = 0\nproject_storage_bytes_allocated = 0\n\nif int(resp['filtered_entity_count']) > 0:\n    entities=[entities for entities in resp['group_results'][0]['entity_results']]\n    vm_data = [data['data'] for data in entities]\n\n    for vm in vm_data:\n        for values in vm:\n            if values['name'] == 'num_vcpus':\n                for value in values['values']:\n                    project_cpu_allocated = project_cpu_allocated + int(value['values'][0])\n            elif values['name'] == 'memory_size_bytes':\n                    for value in values['values']:\n                        project_memory_bytes_allocated = project_memory_bytes_allocated + int(value['values'][0])\n            elif values['name'] == 'capacity_bytes':\n                    for value in values['values']:\n                        project_storage_bytes_allocated = project_storage_bytes_allocated + int(value['values'][0])\n                \n    print(\"Project allocated vCPUs: {}\".format(project_cpu_allocated))\n    print(\"Project allocated memory GB: {}\".format(project_memory_bytes_allocated/1024/1024/1024))\n    print(\"Project allocated storage GB: {}\".format(project_storage_bytes_allocated/1024/1024/1024))\nelse:\n    print(\"Project allocated vCPUs: 0\")\n    print(\"Project allocated memory GB: 0\")\n    print(\"Project allocated storage GB: 0\")\n#endregion get project allocated resources\n\n#region figure out if request complies with quotas\n#compute resources available in the project (quota - allocated)\nproject_available_vcpus = int(project_cpu_quota[0]) - project_cpu_allocated\nprint(\"Project available vCPUs: {}\".format(project_available_vcpus))\nproject_available_memory_bytes = int(project_memory_bytes_quota[0]) - project_memory_bytes_allocated\nprint(\"Project available memory bytes: {}\".format(project_available_memory_bytes))\nproject_available_storage_bytes = int(project_storage_bytes_quota[0]) - project_storage_bytes_allocated\nprint(\"Project available storage bytes: {}\".format(project_available_storage_bytes))\n\n#determine if there are enough resource available to process the request\nif (project_available_vcpus - required_vcpus_count) <= 0:\n    print(\"There aren't enough resources left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_memory_bytes - required_vram_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_storage_bytes - required_storage_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelse:\n    print(\"Project resources quota can accomodate this request.\")\n    exit(0)\n#endregion figure out if request complies with quotas\n\n#endregion main execution\n"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "PcCheckProjectQuota"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "0614ebf8-0a32-45fb-9fbf-dc386ea678dd",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonCreateCluster\n# description:  Deploys a Karbon K8s cluster. Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   create_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\nstorage_class_user = \"@@{storage_class_user.username}@@\"\nstorage_class_user_password = \"@@{storage_class_user.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\n\nworker_node_memory = 1024 * int(\"@@{worker_node_memory}@@\")\nworker_node_disk = 1024 * int(\"@@{worker_node_disk_size}@@\")\nworker_node_cpu = int(\"@@{worker_node_cpu}@@\")\nworker_node_qty = int(\"@@{worker_node_qty}@@\")\n\ncluster_name = \"@@{cluster_name}@@\"\nworker_node_pool = \"@@{cluster_name}@@\" + \"-worker-node-pool\"\nmaster_node_pool = \"@@{cluster_name}@@\" + \"-master-node-pool\"\netcd_node_pool = \"@@{cluster_name}@@\" + \"-etcd-node-pool\"\nfile_system = \"ext4\"\nstorage_container_name = \"@@{storage_container_name}@@\"\nk8s_version = \"@@{k8s_version}@@\"\nimage_name = \"@@{image_name}@@\"\nmaster_config = \"@@{master_config}@@\"\n\npe_cluster_uuid = \"@@{pe_cluster_uuid}@@\"\nsubnet_uuid = \"@@{subnet_uuid}@@\"\n\npod_cidr_range = \"@@{pod_cidr_range}@@\"\nservice_cidr_range = \"@@{service_cidr_range}@@\"\nk8s_cni = \"@@{k8s_cni}@@\"\ncalico_cidr = \"@@{calico_cidr}@@\"\nmaster_vip = \"@@{master_vip}@@\"\nmaster_vip2 = \"@@{master_vip2}@@\"\nexternal_lb = \"@@{external_lb}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters\".format(prism_central_ip)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'POST'\n#initial payload\npayload = {\n  \"cni_config\": {\n    \"node_cidr_mask_size\": 24,\n    \"pod_ipv4_cidr\": pod_cidr_range,\n    \"service_ipv4_cidr\": service_cidr_range\n  },\n  \"etcd_config\": {\n   \n  },\n  \"masters_config\": {\n    \n  },\n  \"metadata\": {\n    \"api_version\": \"v1.0.0\"\n  },\n  \"name\": cluster_name,\n  \"storage_class_config\": {\n    \"default_storage_class\": True,\n    \"name\": \"default-storageclass\",\n    \"reclaim_policy\": \"Delete\",\n    \"volumes_config\": {\n      \"file_system\": file_system,\n      \"flash_mode\": False,\n      \"password\": storage_class_user_password,\n      \"prism_element_cluster_uuid\": pe_cluster_uuid,\n      \"storage_container\": storage_container_name,\n      \"username\": storage_class_user\n    }\n  },\n  \"version\": k8s_version,\n  \"workers_config\": {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": worker_node_cpu,\n        \"disk_mib\": worker_node_disk,\n        \"memory_mib\": worker_node_memory,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": worker_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": worker_node_qty\n    }]\n  }\n}\n#adding cni specific configuration\nif (k8s_cni == \"Flannel\"):\n  print (\"Configuring Flannel CNI\")\n  payload['cni_config']['flannel_config'] = {\n    \"ip_pool_configs\": [{\n      \"cidr\": pod_cidr_range\n    }]   \n  }\nelse:\n  print (\"Configuring Calico CNI\")\n  payload['cni_config']['calico_config'] = {\n    \"ip_pool_configs\": [{\n      \"cidr\": calico_cidr\n    }]   \n  }\n#variations for master/etcd pools and lb configuration\nif (master_config == \"Single Master\"):\n  print (\"Configuring Single Master\")\n  master_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 2,\n        \"disk_mib\": 122880,\n        \"memory_mib\": 4096,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": master_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 1\n    }],\n    \"single_master_config\": { \n      \"external_ipv4_address\": master_vip\n    }\n  }\n  payload['masters_config'] = master_pool  \n  etcd_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 40960,\n        \"memory_mib\": 8192,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": etcd_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 1\n    }]\n  }\n  payload['etcd_config'] = etcd_pool\nelif (master_config == \"Active-Passive\"):\n  print (\"Configuring Active-Passive Master\")\n  master_pool = { \n    \"active_passive_config\": {\n      \"external_ipv4_address\": master_vip\n    },\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 122880,\n        \"memory_mib\": 4096,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": master_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 2\n    }]\n  }\n  payload['masters_config'] = master_pool\n  etcd_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 40960,\n        \"memory_mib\": 8192,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": etcd_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 3\n    }]\n  }\n  payload['etcd_config'] = etcd_pool\nelse:\n  print (\"Configuring Active-Active LoadBalancer Master\")\n  master_pool = {\n    \"external_lb_config\": {\n      \"external_ipv4_address\": external_lb,\n      \"master_nodes_config\": [\n      {\n        \"ipv4_address\": master_vip,\n        \"node_pool_name\": cluster_name\n      },\n      {\n        \"ipv4_address\": master_vip2,\n        \"node_pool_name\": cluster_name\n      }\n    ]},\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 122880,\n        \"memory_mib\": 4096,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": master_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 2\n    }]\n  }\n  payload['masters_config'] = master_pool\n  etcd_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 40960,\n        \"memory_mib\": 8192,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": etcd_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 3\n    }]  \n  }\n  payload['etcd_config'] = etcd_pool\n#endregion prepare the api call\n\n\n#region make the api call\n#print(json.dumps(payload))\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to create cluster was successful\")\nprint (json.loads(resp.content))\ncreate_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(create_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,create_task_uuid)\n\nexit(0)\n#endregion make the api call\n"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonCreateCluster"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "2d422db8-8dd8-4a18-953d-bdd42a9c6408",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220106\n# task_name:    KarbonGetClusterHealth\n# description:  Retrieves health status for a Karbon managed K8s cluster. \n#               Loops until health status can be retrieved or times out after 20 minutes.\n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n\n#region other variables\ntime_out = 20\n#endregion other variables\n\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters/{}/health\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\ncount = 0\nwhile(count < time_out):\n    print(\"Making a GET request to {}\".format(url))\n    resp = requests.get(url, headers=headers, auth=(pc_user, pc_password), verify=False)\n    if resp.ok:\n        print (\"Successfully retrieved health status for the cluster\")\n        print(json.loads(resp.content))\n        exit(0)\n    elif (resp.status_code == 412):\n        print (\"Cluster Health: K8s cluster deployment not ready.  Sleeping for 60 seconds\")\n        count = count + 1\n        sleep(60)\n    else:\n        print (\"Could not retrieve the cluster health status\")\n        print(json.loads(resp.content))\n        exit(1)\n\nprint (\"Error: Operation Timeout after 20 mins\")\nexit(1)\n#endregion make the api call"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonGetClusterHealth"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SET_VARIABLE",
                    "uuid": "20f5f5ec-589a-4434-85eb-2ffda068fa05",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220106\n# task_name:    KarbonGetClusterDetails\n# description:  Retrieves configuration information for a Karbon managed K8s cluster. \n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   kubeapi_server_ipv4_address,k8s_version,karbon_cluster_uuid,node_cidr_mask_size,pod_ipv4_cidr,service_ipv4_cidr\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters/{}\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nprint(\"Making a GET request to {}\".format(url))\nresp = process_request(url, method, pc_user, pc_password, headers)\n    \nprint (\"Successfully retrieved health status for the cluster\")\nprint(json.loads(resp.content))\n\n#* output vars defined here\nkubeapi_server_ipv4_address = resp.json()['kubeapi_server_ipv4_address']\nprint (\"kubeapi_server_ipv4_address={}\".format(kubeapi_server_ipv4_address))\nk8s_version = resp.json()['version']\nprint (\"k8s_version={}\".format(k8s_version))\nkarbon_cluster_uuid = resp.json()['uuid']\nprint (\"karbon_cluster_uuid={}\".format(karbon_cluster_uuid))\nnode_cidr_mask_size = resp.json()['cni_config']['node_cidr_mask_size']\nprint (\"node_cidr_mask_size={}\".format(node_cidr_mask_size))\npod_ipv4_cidr = resp.json()['cni_config']['pod_ipv4_cidr']\nprint (\"pod_ipv4_cidr={}\".format(pod_ipv4_cidr))\nservice_ipv4_cidr = resp.json()['cni_config']['service_ipv4_cidr']\nprint (\"service_ipv4_cidr={}\".format(service_ipv4_cidr))\n\nexit(0)\n#endregion make the api call",
                      "eval_variables": "kubeapi_server_ipv4_address cluster_k8s_version karbon_cluster_uuid",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonGetClusterDetails"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "fb6162f4-4afa-4988-abf6-564709c1b14d",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=1fece5ec_runbook; uuid=a3008208-bcd9-4d1e-9d9f-9785255b6c25}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "UpdateVmProject"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "15a67ab3-fabb-4558-a4d3-a7332239c311",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=55bdcacb_runbook; uuid=cabb5317-1316-4b7c-b8f6-94fea48389b1}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SendKubeconfig"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "0cf026a5-60c1-44d6-9cae-fb0f0299a2fe",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "e1584237_dag",
                  "uuid": "62f3f78b-6bc2-4be4-a7ae-8bdd98ef2c04"
                },
                "name": "82d0a3f5_runbook"
              }
            },
            {
              "description": "System action for deleting an application. Deletes created VMs as well",
              "message_list": [],
              "uuid": "7213b06e-fb87-4f7e-963c-cac83380b4de",
              "name": "action_delete",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "3eac1178-b35f-40b0-89ff-db1a6cf0ac60",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonDeleteCluster; uuid=a539ab13-3d66-4b38-98e0-3b1937caa483}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "d27d7cd9_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "a539ab13-3d66-4b38-98e0-3b1937caa483",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonDeleteCluster\n# description:  Deletes a Karbon K8s cluster. Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   delete_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                return task_status_details\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters/{}\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'DELETE'\n#initial payload\npayload = {}\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to delete cluster was successful\")\nprint(json.loads(resp.content))\ndelete_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(delete_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,delete_task_uuid)\n\nexit(0)\n#endregion make the api call"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonDeleteCluster"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "b9693aa2-8909-4264-9c30-117ac9625899",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "d27d7cd9_dag",
                  "uuid": "3eac1178-b35f-40b0-89ff-db1a6cf0ac60"
                },
                "name": "2cb579b6_runbook"
              }
            },
            {
              "description": "System action for starting an application",
              "message_list": [],
              "uuid": "675a765e-7e8f-4611-98b4-6c7384f43c6a",
              "name": "action_start",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "977a63cb-4e7f-4f00-a1b4-17fdb72faeb8",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "21fd9350_dag"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "7e1ffbb5-989c-4a4a-8194-e7f794fffe72",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "21fd9350_dag",
                  "uuid": "977a63cb-4e7f-4f00-a1b4-17fdb72faeb8"
                },
                "name": "60814c0f_runbook"
              }
            },
            {
              "description": "System action for stopping an application",
              "message_list": [],
              "uuid": "8dc96c9b-b97f-4072-aac1-5382076832f0",
              "name": "action_stop",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "83a51d65-7336-44be-89dc-afa9e8279030",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "8eda2a42_dag"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "80d4576e-128c-4570-95a1-8370c9a7ccdb",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "8eda2a42_dag",
                  "uuid": "83a51d65-7336-44be-89dc-afa9e8279030"
                },
                "name": "46f8c648_runbook"
              }
            },
            {
              "description": "System action for restarting an application",
              "message_list": [],
              "uuid": "a15b72e8-442c-49e7-a359-ccd5ba483fad",
              "name": "action_restart",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "20177a96-69d1-48c9-8ccc-604bed23a753",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "8703dd38_dag"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "0789dd92-4083-484b-b624-e1bf36f1f6d4",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "8703dd38_dag",
                  "uuid": "20177a96-69d1-48c9-8ccc-604bed23a753"
                },
                "name": "91fdabc1_runbook"
              }
            },
            {
              "description": "",
              "message_list": [],
              "uuid": "b4dc14c1-33bb-4aa8-b615-5096f976f4ce",
              "name": "SendKubeconfig",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "user",
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "1dde26d7-2ad3-4806-ac02-e2837f09f948",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonGetKubeconfig; uuid=ee27f3d1-1be4-4e90-8815-04d770780bd1}",
                      "@{kind=app_task; name=SendMail; uuid=f1a9aa98-3be9-4562-ad29-d0f243b99ad4}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "a1aa7936_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SET_VARIABLE",
                    "uuid": "ee27f3d1-1be4-4e90-8815-04d770780bd1",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220106\n# task_name:    KarbonGetKubeConfig\n# description:  Retrieves kubeconfig for the given Karbon cluster. \n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   kubeconfig\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters/{}/kubeconfig\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers)\n#* output vars defined here\nkubeconfig = resp.json()['kube_config']\n\nencodedBytes = base64.b64encode(kubeconfig.encode(\"utf-8\"))\nencodedStr = str(encodedBytes)\nprint (\"kubeconfig={}\".format(encodedStr))\n\nexit(0)\n#endregion make the api call",
                      "eval_variables": "kubeconfig",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonGetKubeconfig"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "f1a9aa98-3be9-4562-ad29-d0f243b99ad4",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "exit_status": "",
                      "script": "#!/bin/bash\n\n# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0/20210504 - cita-starter version\n# task_name:    SendMail\n# description:  sends an email notification to the Calm user including kubeconfig.               \n# output vars:  none\n# dependencies: none\n# endregion\n\nFrom=@@{email_sender}@@\nTo=@@{requester_email}@@\nSubject=\"Your Kubernetes kubeconfig\"\nAttachment=\"/tmp/@@{cluster_name}@@-kubeconfig\"\n\n#tee ${Attachment}\necho \"@@{kubeconfig}@@\" | base64 --decode > ${Attachment}\ngzip -f ${Attachment}\n\necho \"\nfrom email.message import EmailMessage\nfrom email.mime.multipart import MIMEMultipart\nimport smtplib\nimport os\nfrom email.mime.base import MIMEBase\nfrom email.mime.text import MIMEText\nfrom email import encoders\n\nserver = smtplib.SMTP(\"\\\"@@{smtp_server}@@\\\"\", 25)\n\nmsg = MIMEMultipart()\nBody = MIMEText('Hello,\\n\\nYou have requested a kubernetes cluster which was successfully deployed with version @@{cluster_k8s_version}@@.\\n\\nYou can connect to it using the following information:\\n\\tService type: Kubernetes Cluster\\n\\tK8s ip address: @@{kubeapi_server_ipv4_address}@@\\n\\tK8s cluster name: @@{cluster_name}@@\\n\\nYou can use the attached kubeconfig or the following kubectl plugin to log into your k8s cluster: https://github.com/nutanix/kubectl-karbon\\n\\nNote that the Prism Central IP address is @@{prism_central_ip}@@\\n\\nRegards,\\n\\nYour IT Team')\nmsg['Subject'] = '${Subject}'\nmsg['From'] = '${From}'\nmsg['To'] = '${To}'\nmsg.attach(Body)\n\npart = MIMEBase('application', 'octet-stream')\npart.set_payload(open('${Attachment}.gz', 'rb').read())\nencoders.encode_base64(part)\npart.add_header('Content-Disposition', 'attachment; filename=${Attachment}.gz')\nmsg.attach(part)\n\nserver.sendmail(msg['From'], [msg['To']], msg.as_string())\" | tee  ~/send_notification\n\necho \"Sending user notification\"\n\npython3 ~/send_notification\n\nrm ~/send_notification\nrm \"${Attachment}.gz\"",
                      "script_type": "sh",
                      "type": "",
                      "command_line_args": "",
                      "login_credential_local_reference": "@{kind=app_credential; name=linux; uuid=11dc086e-56a7-4fb6-a284-02549f1cf473}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SendMail"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "cabb5317-1316-4b7c-b8f6-94fea48389b1",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "a1aa7936_dag",
                  "uuid": "1dde26d7-2ad3-4806-ac02-e2837f09f948"
                },
                "name": "55bdcacb_runbook"
              }
            },
            {
              "description": "",
              "message_list": [],
              "uuid": "1cb79c23-c3c9-447a-aedd-5c8a298261a2",
              "name": "UpdateVmProject",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "user",
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "58f23ccf-54a6-4174-89b6-7d16f42c795f",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonGetNodePoolsVmHostnames; uuid=03fe7f12-ecc0-43cc-9d04-859be30a40a8}",
                      "@{kind=app_task; name=PcUpdateVmProject; uuid=7a2ad120-0f41-40a9-85d8-716f2deb6d8a}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "8d908151_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SET_VARIABLE",
                    "uuid": "03fe7f12-ecc0-43cc-9d04-859be30a40a8",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonGetNodePoolsVmHostnames\n# description:  Given a Karbon cluster name, get all the vm node hostnames from all existing pools. \n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   k8s_cluster_node_vms\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1-alpha.1/k8s/clusters/{}/node-pools\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#initial payload\npayload = {}\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\n\ncontents = json.loads(resp.content)\nk8s_cluster_nodes = [item.get('nodes') for item in contents]\n\nk8s_cluster_node_vms=[]\nfor list in k8s_cluster_nodes:\n    for item in list:\n        k8s_cluster_node_vms.append(item['hostname'])\n\nprint (\"k8s_cluster_node_vms={}\".format(k8s_cluster_node_vms))\n\nexit(0)\n#endregion make the api call\n",
                      "eval_variables": "k8s_cluster_node_vms",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonGetNodePoolsVmHostnames"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "7a2ad120-0f41-40a9-85d8-716f2deb6d8a",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    PcUpdateVmProject\n# description:  Given a list of vms and a project reference, update all those vms project with the new project reference.\n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_reference = json.loads('@@{project_reference}@@')\nvm_list = @@{k8s_cluster_node_vms}@@\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_vms(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of VMs from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of VMs (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/vms/list\"\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"vm\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"vm\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n#endregion functions\n\n#region main processing\n#* get all vms\nvms = prism_get_vms(prism_central_ip,pc_user,pc_password)\n\n#*foreach given vm in the list\nfor vm in vm_list:\n    #* figure out spec and metadata payload for that vm\n    for vm_object in vms:\n        if vm_object['spec']['name'] == vm:\n            vm_uuid = vm_object['metadata']['uuid']\n            vm_details = vm_object.copy()\n            break\n    vm_details.pop('status')\n    del vm_details['metadata']['entity_version']\n    #print(\"before: {}\".format(vm_details))\n    #* update project reference\n    if vm_details['metadata']['project_reference']['name'] != project_reference['name']:\n        vm_details['metadata']['project_reference'] = project_reference\n        print(\"updated metadata section: {}\".format(json.dumps(vm_details['metadata'])))\n        print(\"vm_uuid: {}\".format(vm_uuid))\n        \n        #* update vm with put\n        #region prepare the api call\n        url = \"https://{}:9440/api/nutanix/v3/vms/{}\".format(prism_central_ip,vm_uuid)\n        headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}\n        method = 'PUT'\n        #initial payload\n        payload = vm_details\n        #print(\"payload: {}\".format(json.dumps(payload)))\n        #endregion prepare the api call\n        #region make the api call\n        print(\"Making a {} API call to {}\".format(method, url))\n        resp = process_request(url, method, pc_user, pc_password, headers, payload)\n        print (\"Updated virtual machine {} with project {}\".format(vm_details['spec']['name'],project_reference['name']))\n        print(json.loads(resp.content))\n        #endregion make the api call\n    else:\n        print(\"Project for vm {} is already {}. Skipping.\".format(vm_details['spec']['name'],project_reference['name']))\n\nexit(0)\n\n\n#endregion main processing"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "PcUpdateVmProject"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "a3008208-bcd9-4d1e-9d9f-9785255b6c25",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "8d908151_dag",
                  "uuid": "58f23ccf-54a6-4174-89b6-7d16f42c795f"
                },
                "name": "1fece5ec_runbook"
              }
            },
            {
              "description": "System action for deleting an application. Does not delete created VMs",
              "message_list": [],
              "uuid": "2b22ea59-6a4e-4dbb-9082-72e271567858",
              "name": "action_soft_delete",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "072797d8-6624-411b-acc4-430e57569362",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__Service_Element_Delete_b27e4680_02a6_4808_b991_74c245247d07; uuid=22aedaa6-8822-4c64-afa9-c1352ae214c3}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SOFT_DELETE_ELEMENT",
                    "uuid": "22aedaa6-8822-4c64-afa9-c1352ae214c3",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Service_Element_Delete_b27e4680_02a6_4808_b991_74c245247d07"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "1a689ca6-aa5c-4825-8255-92860f6d14b2",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Service_b27e4680_02a6_4808_b991_74c245247d07",
                  "uuid": "072797d8-6624-411b-acc4-430e57569362"
                },
                "name": "SYS_GEN__Runbook_Service_b27e4680_02a6_4808_b991_74c245247d07"
              }
            }
          ],
          "message_list": [],
          "uuid": "b27e4680-02a6-4808-b991-74c245247d07",
          "state": "ACTIVE",
          "depends_on_list": [],
          "editables": {},
          "tier": "",
          "singleton": false,
          "variable_list": [
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "24818a4e-acc0-45db-bd7f-758ffd4ba555",
              "value": "",
              "label": "Kubernetes Management IP",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {},
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "kubeapi_server_ipv4_address"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "13f844b1-2f23-4615-80cc-2af251b7d619",
              "value": "",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {},
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "cluster_k8s_version"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "98a2dbd0-715a-4195-b21e-7b7b7aa92067",
              "value": "",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "is_secret_modified": false,
                "secret_reference": {
                  "uuid": "26a53672-3ab5-4b56-9cb2-1a93fba8fb72"
                },
                "type": "SECRET"
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "type": "SECRET",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "kubeconfig"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "9fb8028c-b8e4-4bf6-9488-3810e18bdf83",
              "value": "",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {},
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "project_reference"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "d3a74b19-30e8-4f0f-aec7-a5d72bd622e5",
              "value": "",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {},
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "k8s_cluster_node_vms"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "e3763343-6410-463a-b3cf-67145ba37c3f",
              "value": "",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {},
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "karbon_cluster_uuid"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "fa1ea242-c932-4ae7-a1ea-ae3015d7b0ca",
              "value": "",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "image_uuid"
            }
          ],
          "name": "ManagementService"
        }
      ],
      "substrate_definition_list": [
        {
          "description": "",
          "action_list": [
            {
              "description": "System action for creating an application",
              "message_list": [],
              "uuid": "31c3da02-9e9b-419b-aeeb-7dcf19a93ed8",
              "name": "action_create",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "83c1ea85-449b-4b81-bebc-3bb01118e4a5",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__Existing_Machine_Provision_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=ef9e8b0d-c5a1-44f0-9a8f-28b1c8fef34d}",
                      "@{kind=app_task; name=SYS_GEN__check_login_for_ManagementLinuxVM_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=28ad4e96-0fc2-4ae3-9095-f4b3ac3a0ee3}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "PROVISION_EXISTING_MACHINE",
                    "uuid": "ef9e8b0d-c5a1-44f0-9a8f-28b1c8fef34d",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "type": "PROVISION_EXISTING_MACHINE",
                      "address": "10.48.111.42"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Existing_Machine_Provision_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CHECK_LOGIN",
                    "uuid": "28ad4e96-0fc2-4ae3-9095-f4b3ac3a0ee3",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "retries": "5",
                      "dial_timeout": "",
                      "timeout": "60",
                      "address": "@@{ip_address}@@",
                      "type": "CHECK_LOGIN",
                      "sleep_time": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__check_login_for_ManagementLinuxVM_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "b14c0748-81f0-482d-93de-4b0395d88225",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec",
                  "uuid": "83c1ea85-449b-4b81-bebc-3bb01118e4a5"
                },
                "name": "SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
              }
            },
            {
              "description": "System action for powering on an application",
              "message_list": [],
              "uuid": "0b3d377d-b030-4261-8eb5-ed780ea60648",
              "name": "action_poweron",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "ef3a025e-c78f-4a6f-8b2b-e76eece30e1e",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__Existing_Machine_Operation_PowerOn_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=59d2ae8f-f23b-49a5-9d94-2647cdcccb01}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXISTING_MACHINE_OPERATION",
                    "uuid": "59d2ae8f-f23b-49a5-9d94-2647cdcccb01",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "operation_type": "action_poweron",
                      "type": "GENERIC_OPERATION"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Existing_Machine_Operation_PowerOn_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "e875c072-d6cf-4ff7-bcbe-b3bf9d99039d",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec",
                  "uuid": "ef3a025e-c78f-4a6f-8b2b-e76eece30e1e"
                },
                "name": "SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
              }
            },
            {
              "description": "System action for restarting an application",
              "message_list": [],
              "uuid": "9b92b53e-4a52-450b-ab75-97169e3aee90",
              "name": "action_restart",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "8d96d688-525a-48b5-90ad-b3921cf3ab9e",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__Existing_Machine_Operation_Restart_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=fd6cf436-6f7d-4d92-a76e-2ee23e8d9d9d}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXISTING_MACHINE_OPERATION",
                    "uuid": "fd6cf436-6f7d-4d92-a76e-2ee23e8d9d9d",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "operation_type": "action_restart",
                      "type": "GENERIC_OPERATION"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Existing_Machine_Operation_Restart_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "e81c8176-68ad-40ba-baea-036c4fff63f3",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec",
                  "uuid": "8d96d688-525a-48b5-90ad-b3921cf3ab9e"
                },
                "name": "SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
              }
            },
            {
              "description": "System action for suspending an application",
              "message_list": [],
              "uuid": "78a330b7-9151-440b-bf7f-49a202f2e142",
              "name": "action_suspend",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "6bafffcc-6bbd-4dfb-9243-6d678b302194",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "090242a7-bc9f-4073-b5c0-7fb1cddcde75",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec",
                  "uuid": "6bafffcc-6bbd-4dfb-9243-6d678b302194"
                },
                "name": "SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
              }
            },
            {
              "description": "System action for modifying an application",
              "message_list": [],
              "uuid": "88b70e50-2df8-4307-993f-ab4ead56b4fb",
              "name": "action_modify",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "b6981b56-70f6-4b6b-81a7-c77b683f6716",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "318de543-cbcc-4288-bb22-f4ef0e2ab7d9",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec",
                  "uuid": "b6981b56-70f6-4b6b-81a7-c77b683f6716"
                },
                "name": "SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
              }
            },
            {
              "description": "System action for powering off an application",
              "message_list": [],
              "uuid": "812dc2f1-fd43-4f75-bedd-76505ff1af01",
              "name": "action_poweroff",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "08433c25-ff9b-408a-8963-cbc7789da104",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__Existing_Machine_Operation_PowerOff_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=c42b5bfc-8553-4d1b-8a39-b7c9452ee928}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXISTING_MACHINE_OPERATION",
                    "uuid": "c42b5bfc-8553-4d1b-8a39-b7c9452ee928",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "operation_type": "action_poweroff",
                      "type": "GENERIC_OPERATION"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Existing_Machine_Operation_PowerOff_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "c4242ebd-c802-4bda-9e87-a6f074c30dbb",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec",
                  "uuid": "08433c25-ff9b-408a-8963-cbc7789da104"
                },
                "name": "SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
              }
            },
            {
              "description": "System action for deleting an application. Deletes created VMs as well",
              "message_list": [],
              "uuid": "9f0c1b7e-c6a6-4162-86d1-69626a407fd6",
              "name": "action_delete",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "441d17ed-838c-41e1-ad26-6176e792d7d3",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__Existing_Machine_Delete_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=4b7d835d-e2d7-484c-aa30-796aacc2dd87}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXISTING_MACHINE_DELETE",
                    "uuid": "4b7d835d-e2d7-484c-aa30-796aacc2dd87",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Existing_Machine_Delete_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "cb8e4c3e-3f00-4998-9bad-0346ab457d12",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec",
                  "uuid": "441d17ed-838c-41e1-ad26-6176e792d7d3"
                },
                "name": "SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
              }
            },
            {
              "description": "System action for deleting an application. Does not delete created VMs",
              "message_list": [],
              "uuid": "52f2a3bb-02b3-476e-87d8-95c380beb50d",
              "name": "action_soft_delete",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "5fa3ddc7-43e9-492c-90f8-d4855b992791",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__Substrate_Element_Delete_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=88120d96-34b8-442c-989d-a6762696ead5}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SOFT_DELETE_ELEMENT",
                    "uuid": "88120d96-34b8-442c-989d-a6762696ead5",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Substrate_Element_Delete_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "a956d0ed-b881-4568-b09f-80b58efbee07",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec",
                  "uuid": "5fa3ddc7-43e9-492c-90f8-d4855b992791"
                },
                "name": "SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
              }
            }
          ],
          "message_list": [],
          "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec",
          "state": "ACTIVE",
          "readiness_probe": {
            "connection_type": "SSH",
            "retries": "5",
            "connection_protocol": "",
            "disable_readiness_probe": false,
            "address": "@@{ip_address}@@",
            "delay_secs": "60",
            "connection_port": 22,
            "login_credential_local_reference": {
              "kind": "app_credential",
              "name": "linux",
              "uuid": "11dc086e-56a7-4fb6-a284-02549f1cf473"
            }
          },
          "editables": {},
          "os_type": "Linux",
          "type": "EXISTING_VM",
          "create_spec": {
            "type": "PROVISION_EXISTING_MACHINE",
            "address": "10.48.111.42"
          },
          "variable_list": [],
          "name": "ManagementLinuxVM"
        }
      ],
      "credential_definition_list": [
        {
          "username": "stephane.bourdeaud@emeagso.lab",
          "description": "",
          "state": "ACTIVE",
          "uuid": "2b72530b-dc51-4074-b42d-e84bd60b4a1a",
          "secret": {
            "attrs": {
              "is_secret_modified": false,
              "secret_reference": {}
            }
          },
          "editables": {},
          "cred_class": "static",
          "type": "PASSWORD",
          "name": "prism_central"
        },
        {
          "username": "stephane.bourdeaud@emeagso.lab",
          "description": "",
          "state": "ACTIVE",
          "uuid": "baf28e67-a05b-4166-8a11-5b39f70ac482",
          "secret": {
            "attrs": {
              "is_secret_modified": false,
              "secret_reference": {}
            }
          },
          "editables": {},
          "cred_class": "static",
          "type": "PASSWORD",
          "name": "storage_class_user"
        },
        {
          "username": "centos",
          "description": "",
          "state": "ACTIVE",
          "uuid": "11dc086e-56a7-4fb6-a284-02549f1cf473",
          "secret": {
            "attrs": {
              "is_secret_modified": false,
              "secret_reference": {}
            }
          },
          "editables": {},
          "cred_class": "static",
          "type": "KEY",
          "name": "linux"
        }
      ],
      "type": "USER",
      "app_profile_list": [
        {
          "deployment_create_list": [
            {
              "description": "",
              "action_list": [
                {
                  "description": "System action for creating an application",
                  "message_list": [],
                  "uuid": "f8b9f185-7d26-4113-a0b8-dcb432f8f49b",
                  "name": "action_create",
                  "state": "ACTIVE",
                  "critical": true,
                  "attrs": {},
                  "type": "system",
                  "runbook": {
                    "task_definition_list": [
                      "@{target_any_local_reference=; retries=0; description=; type=DAG; uuid=1a34b18c-93f2-47cc-a25a-3a61c503099b; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}",
                      "@{target_any_local_reference=; retries=0; description=; type=CREATE_DEPLOYMENT_ELEMENT; uuid=f0ee4a12-4477-4476-8c86-9f535955f930; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__DE_Provision_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=e8f57059-594f-425a-9e83-63ce4599fdcf; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__create_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=b273c071-292f-4961-b928-c18b4f4e85e2; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__install_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=160fecb7-c024-4f6c-9ebd-29a954aeb9cb; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__create_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=864cedf5-c193-434e-a7fe-1d823ec805c1; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07}"
                    ],
                    "description": "",
                    "message_list": [],
                    "uuid": "4cc0ad0e-1b4a-4bcc-9222-6dd124b50994",
                    "state": "ACTIVE",
                    "variable_list": [],
                    "main_task_local_reference": {
                      "kind": "app_task",
                      "name": "SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a",
                      "uuid": "1a34b18c-93f2-47cc-a25a-3a61c503099b"
                    },
                    "name": "SYS_GEN__Runbook_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                },
                {
                  "description": "System action for starting an application",
                  "message_list": [],
                  "uuid": "5beb3bfd-3495-46a6-90d7-f072aabcc515",
                  "name": "action_start",
                  "state": "ACTIVE",
                  "critical": true,
                  "attrs": {},
                  "type": "system",
                  "runbook": {
                    "task_definition_list": [
                      "@{target_any_local_reference=; retries=0; description=; type=DAG; uuid=9b899c18-38cb-4cea-b33f-66fb418f4b56; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=0494446c-4adc-4096-9ae7-a98b8880e892; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__start_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=57f69bc8-c609-4eb8-98ed-01383844a53a; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07}"
                    ],
                    "description": "",
                    "message_list": [],
                    "uuid": "6ed5187c-65f5-4882-aa9c-c5f19f5222cf",
                    "state": "ACTIVE",
                    "variable_list": [],
                    "main_task_local_reference": {
                      "kind": "app_task",
                      "name": "SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a",
                      "uuid": "9b899c18-38cb-4cea-b33f-66fb418f4b56"
                    },
                    "name": "SYS_GEN__Runbook_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                },
                {
                  "description": "System action for restarting an application",
                  "message_list": [],
                  "uuid": "81c41b56-29f5-4bdd-9a96-dae2bb851806",
                  "name": "action_restart",
                  "state": "ACTIVE",
                  "critical": true,
                  "attrs": {},
                  "type": "system",
                  "runbook": {
                    "task_definition_list": [
                      "@{target_any_local_reference=; retries=0; description=; type=DAG; uuid=da588182-baa2-4bd1-8ae6-1aac6d8bb714; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=7d03c2d2-71ac-4b49-bb65-3aa8da3531f3; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__restart_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=25d380f5-af7a-4ce9-aefb-66cc95c4c136; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__restart_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07}"
                    ],
                    "description": "",
                    "message_list": [],
                    "uuid": "8dabe437-60d9-40ca-8e78-419542bc9574",
                    "state": "ACTIVE",
                    "variable_list": [],
                    "main_task_local_reference": {
                      "kind": "app_task",
                      "name": "SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a",
                      "uuid": "da588182-baa2-4bd1-8ae6-1aac6d8bb714"
                    },
                    "name": "SYS_GEN__Runbook_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                },
                {
                  "description": "System action for stopping an application",
                  "message_list": [],
                  "uuid": "14c0afb2-2e9a-4981-8053-a38eb93fe446",
                  "name": "action_stop",
                  "state": "ACTIVE",
                  "critical": true,
                  "attrs": {},
                  "type": "system",
                  "runbook": {
                    "task_definition_list": [
                      "@{target_any_local_reference=; retries=0; description=; type=DAG; uuid=f85ee405-f70d-4e77-a504-9979db7f1e48; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=858fcc14-6594-48db-8d1b-83af601ad16e; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=6afe40e8-768c-4d50-aadb-e36883710cfd; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__stop_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec}"
                    ],
                    "description": "",
                    "message_list": [],
                    "uuid": "39d4059a-9e98-489f-99a8-605737e6284e",
                    "state": "ACTIVE",
                    "variable_list": [],
                    "main_task_local_reference": {
                      "kind": "app_task",
                      "name": "SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a",
                      "uuid": "f85ee405-f70d-4e77-a504-9979db7f1e48"
                    },
                    "name": "SYS_GEN__Runbook_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                },
                {
                  "description": "System action for deleting an application. Deletes created VMs as well",
                  "message_list": [],
                  "uuid": "43e23c15-43a7-44f4-913f-c3ac33fa3b3c",
                  "name": "action_delete",
                  "state": "ACTIVE",
                  "critical": true,
                  "attrs": {},
                  "type": "system",
                  "runbook": {
                    "task_definition_list": [
                      "@{target_any_local_reference=; retries=0; description=; type=DAG; uuid=a02a9c26-1729-4e96-b4cf-3f0723eff714; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=861ea0f7-0bea-4af9-9a56-18b0a3d92595; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=f997250d-108c-48de-8213-6c70b927f6d9; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=5e82855c-cb1d-4ad6-bf1d-50dd739ba5a7; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__uninstall_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=979b8eea-c2f3-4935-9911-e3e7af1cbbc1; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__delete_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec}",
                      "@{target_any_local_reference=; retries=0; description=; type=DELETE_DEPLOYMENT_ELEMENT; uuid=62df9682-7c1a-44c9-a9ec-100b0b0a2903; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__DE_Delete_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}"
                    ],
                    "description": "",
                    "message_list": [],
                    "uuid": "151bd08b-1d43-4960-91f7-b2ffd1946ce2",
                    "state": "ACTIVE",
                    "variable_list": [],
                    "main_task_local_reference": {
                      "kind": "app_task",
                      "name": "SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a",
                      "uuid": "a02a9c26-1729-4e96-b4cf-3f0723eff714"
                    },
                    "name": "SYS_GEN__Runbook_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                },
                {
                  "description": "System action for scaleout",
                  "message_list": [],
                  "uuid": "63dc917b-6182-4f47-93c9-be8d2e253797",
                  "name": "action_scaleout",
                  "state": "ACTIVE",
                  "critical": true,
                  "attrs": {},
                  "type": "system",
                  "runbook": {
                    "task_definition_list": [
                      "@{target_any_local_reference=; retries=0; description=; type=DAG; uuid=ab43fed8-1a76-48b2-96eb-a9af8dd9fb24; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}",
                      "@{target_any_local_reference=; retries=0; description=; type=SCALING; uuid=9f33f273-6800-4d98-a5cc-9dacaac08119; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Deployment_Scaleout_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}"
                    ],
                    "description": "",
                    "message_list": [],
                    "uuid": "69e65499-1037-4d90-b906-6c6d3173f1e9",
                    "state": "ACTIVE",
                    "variable_list": [
                      "@{regex=; val_type=STRING; is_mandatory=False; description=; data_type=BASE; message_list=System.Object[]; uuid=42eb48b8-ef7c-4949-b1a2-b6696aa3dae0; value=0; label=; state=NOT_VALIDATED; attrs=; editables=; is_hidden=False; type=LOCAL; options=; name=scaling_count}"
                    ],
                    "main_task_local_reference": {
                      "kind": "app_task",
                      "name": "SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a",
                      "uuid": "ab43fed8-1a76-48b2-96eb-a9af8dd9fb24"
                    },
                    "name": "SYS_GEN__Runbook_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                },
                {
                  "description": "System action for scalein",
                  "message_list": [],
                  "uuid": "adff4630-5bab-4573-8a80-9f87ec4956eb",
                  "name": "action_scalein",
                  "state": "ACTIVE",
                  "critical": true,
                  "attrs": {},
                  "type": "system",
                  "runbook": {
                    "task_definition_list": [
                      "@{target_any_local_reference=; retries=0; description=; type=DAG; uuid=58417a15-6bc0-45f2-b4e5-c366b590425b; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}",
                      "@{target_any_local_reference=; retries=0; description=; type=SCALING; uuid=915eb1fe-e69c-499d-9fb3-3856f49e409e; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Deployment_Scalein_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}"
                    ],
                    "description": "",
                    "message_list": [],
                    "uuid": "70274723-9e4f-4959-9079-0c5ed3b8887a",
                    "state": "ACTIVE",
                    "variable_list": [
                      "@{regex=; val_type=STRING; is_mandatory=False; description=; data_type=BASE; message_list=System.Object[]; uuid=1c00a574-7e71-496b-9e26-6aaaf9683c0d; value=0; label=; state=NOT_VALIDATED; attrs=; editables=; is_hidden=False; type=LOCAL; options=; name=scaling_count}"
                    ],
                    "main_task_local_reference": {
                      "kind": "app_task",
                      "name": "SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a",
                      "uuid": "58417a15-6bc0-45f2-b4e5-c366b590425b"
                    },
                    "name": "SYS_GEN__Runbook_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                },
                {
                  "description": "System action for deleting an application. Does not delete created VMs",
                  "message_list": [],
                  "uuid": "4a9def2c-1ffb-4118-a61d-2b21d08eab98",
                  "name": "action_soft_delete",
                  "state": "ACTIVE",
                  "critical": true,
                  "attrs": {},
                  "type": "system",
                  "runbook": {
                    "task_definition_list": [
                      "@{target_any_local_reference=; retries=0; description=; type=DAG; uuid=357363f6-496a-4355-9f0b-d4a75b15f290; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=5350d606-d9e3-4166-8384-8c10da2ac71b; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__soft_delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07}",
                      "@{target_any_local_reference=; retries=0; description=; type=SOFT_DELETE_ELEMENT; uuid=f540e77f-0d50-424c-809e-1bdfc05d6a46; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__Package_Element_Delete_b17d1c3e_3491_47a4_802b_ea7c2c28bec2}",
                      "@{target_any_local_reference=; retries=0; description=; type=CALL_RUNBOOK; uuid=cb463c13-deba-4663-8b6d-b034aeb85e05; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__soft_delete_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec}",
                      "@{target_any_local_reference=; retries=0; description=; type=SOFT_DELETE_DEPLOYMENT_ELEMENT; uuid=7717a85f-d515-4d44-a06c-9e2235701315; child_tasks_local_reference_list=System.Object[]; state=ACTIVE; attrs=; timeout_secs=0; inherit_target=False; message_list=System.Object[]; variable_list=System.Object[]; name=SYS_GEN__DE_Soft_Delete_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a}"
                    ],
                    "description": "",
                    "message_list": [],
                    "uuid": "c5c81857-c95c-4dce-b5ea-fce033c50042",
                    "state": "ACTIVE",
                    "variable_list": [],
                    "main_task_local_reference": {
                      "kind": "app_task",
                      "name": "SYS_GEN__Composite_DAG_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a",
                      "uuid": "357363f6-496a-4355-9f0b-d4a75b15f290"
                    },
                    "name": "SYS_GEN__Runbook_Deployment_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                }
              ],
              "message_list": [],
              "published_service_local_reference_list": [],
              "uuid": "9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a",
              "default_replicas": "1",
              "min_replicas": "1",
              "state": "ACTIVE",
              "max_replicas": "1",
              "depends_on_list": [],
              "editables": {},
              "package_local_reference_list": [
                {
                  "kind": "app_package",
                  "name": "Package1",
                  "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                }
              ],
              "substrate_local_reference": {
                "kind": "app_substrate",
                "name": "ManagementLinuxVM",
                "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
              },
              "type": "GREENFIELD",
              "options": {},
              "variable_list": [],
              "name": "1c2a7ea2_deployment"
            }
          ],
          "environment_reference_list": [],
          "application_url": "",
          "description": "",
          "action_list": [
            {
              "description": "",
              "message_list": [],
              "uuid": "5772d6a0-7bc9-4020-81c0-e58b79d6e1a5",
              "name": "Add Worker Node",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "user",
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "2ab60d03-f165-4652-b8c9-e2c6b1b3efe7",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=PcCheckProjectQuota; uuid=f04a62cf-c115-49fb-9dad-9ddf7c78d2de}",
                      "@{kind=app_task; name=KarbonAddWorkerNode; uuid=ce68065e-b183-48dc-b99b-0aaf1e13381c}",
                      "@{kind=app_task; name=UpdateVmProject; uuid=6fc6e4cc-bc23-4a8f-bbdf-9888d0242181}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": " ",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "6f43296c_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "f04a62cf-c115-49fb-9dad-9ddf7c78d2de",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220111\n# task_name:    PcCheckProjectQuota\n# description:  Given a project name, check the project quota against provided resources. \n#               If there are not enough available resources in the quota, returns a failure code.\n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_reference = json.loads('@@{project_reference}@@')\nworker_node_cpu_count = int(\"@@{worker_node_cpu}@@\")\nworker_node_vram_bytes = int(\"@@{worker_node_memory}@@\")*1024*1024*1024\nworker_node_storage_bytes = (int(\"@@{worker_node_disk_size}@@\")+40)*1024*1024*1024\nworker_node_qty = int(\"@@{add_worker_node_count}@@\")\n\n\n\n#worker node(s) + master node(s) + etcd node(s) \nrequired_vcpus_count = (int(worker_node_cpu_count) * int(worker_node_qty))\nrequired_vram_bytes = (int(worker_node_vram_bytes) * int(worker_node_qty))\nrequired_storage_bytes = (int(worker_node_storage_bytes) * int(worker_node_qty))\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_projects(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of Projects from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of Projects (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/projects/list\"\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"project\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"project\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n\ndef prism_get_project(api_server,username,secret,project_name=None,project_uuid=None,secure=False):\n    \"\"\"Returns from Prism Central the uuid and details of a given project name.\n       If a project_uuid is specified, it will skip retrieving all vms (faster).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        project_name: Name of the project.\n        project_uuid: Uuid of the project (optional).\n        \n    Returns:\n        A string containing the UUID of the Project (project_uuid) and the json content\n        of the project details (project_details)\n    \"\"\"\n    project_details = {}\n\n    if project_uuid is None:\n        #get the list vms from Prism\n        project_list = prism_get_projects(api_server,username,secret,secure)\n        for project in project_list:\n            if project['spec']['name'] == project_name:\n                project_uuid = project['metadata']['uuid']\n                project_details = project.copy()\n                break\n    else:\n        headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n        }\n        api_server_port = \"9440\"\n        api_server_endpoint = \"/api/nutanix/v3/projects/{0}\".format(project_uuid)\n        url = \"https://{}:{}{}\".format(\n            api_server,\n            api_server_port,\n            api_server_endpoint\n        )\n        method = \"GET\"\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,secure)\n        if resp.ok:\n            project_details = json.loads(resp.content)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n    return project_uuid, project_details\n\n#endregion functions\n\n\n#region main execution\n\nprint(\"Provisioning request required vCPUs: {}\".format(required_vcpus_count))\nprint(\"Provisioning request required memory GB: {}\".format(required_vram_bytes/1024/1024/1024))\nprint(\"Provisioning request required storage GB: {}\".format(required_storage_bytes/1024/1024/1024))\n\n\n#region get project quotas\nproject_uuid,project_details = prism_get_project(prism_central_ip,pc_user,pc_password,project_uuid=project_reference['uuid'])\n#get resource total allocated quota from the project definition\nproject_cpu_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'VCPUS']\nprint(\"Project vCPU quota: {}\".format(project_cpu_quota[0]))\nproject_memory_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'MEMORY']\nprint(\"Project memory GB quota: {}\".format(int(project_memory_bytes_quota[0])/1024/1024/1024))\nproject_storage_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'STORAGE']\nprint(\"Project storage GB quota: {}\".format(int(project_storage_bytes_quota[0])/1024/1024/1024))\n#endregion get project quotas\n\n#region get project allocated resources\n#retrieve list of project vms and their current resource allocation\n#region api call\nheaders = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n}\napi_server_port = \"9440\"\napi_server_endpoint = \"/api/nutanix/v3/groups\"\nurl = \"https://{}:{}{}\".format(\n    prism_central_ip,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\npayload = {\n    \"entity_type\": \"mh_vm\",\n    \"group_member_count\": 500,\n    \"group_member_offset\": 0,\n    \"group_member_attributes\": [\n        {\n            \"attribute\": \"memory_size_bytes\"\n        },\n        {\n            \"attribute\": \"capacity_bytes\"\n        },\n        {\n            \"attribute\": \"num_vcpus\"\n        },\n        {\n            \"attribute\": \"project_reference\"\n        },\n        {\n            \"attribute\": \"project_name\"\n        }\n    ],\n    \"query_name\": \"prism:EBQueryModel\",\n    \"availability_zone_scope\": \"GLOBAL\",\n    \"filter_criteria\": \"(platform_type!=aws,platform_type==[no_val]);project_reference=in={}\".format(project_uuid)\n}\nprint(\"Making a {} API call to {}\".format(method, url))\nr = process_request(url,method,pc_user,pc_password,headers,payload)\n#endregion api call\n\n#compute total current resource allocation\nresp = json.loads(r.content)\n\n\nproject_cpu_allocated = 0\nproject_memory_bytes_allocated = 0\nproject_storage_bytes_allocated = 0\n\nif int(resp['filtered_entity_count']) > 0:\n    entities=[entities for entities in resp['group_results'][0]['entity_results']]\n    vm_data = [data['data'] for data in entities]\n\n    for vm in vm_data:\n        for values in vm:\n            if values['name'] == 'num_vcpus':\n                for value in values['values']:\n                    project_cpu_allocated = project_cpu_allocated + int(value['values'][0])\n            elif values['name'] == 'memory_size_bytes':\n                    for value in values['values']:\n                        project_memory_bytes_allocated = project_memory_bytes_allocated + int(value['values'][0])\n            elif values['name'] == 'capacity_bytes':\n                    for value in values['values']:\n                        project_storage_bytes_allocated = project_storage_bytes_allocated + int(value['values'][0])\n                \n    print(\"Project allocated vCPUs: {}\".format(project_cpu_allocated))\n    print(\"Project allocated memory GB: {}\".format(project_memory_bytes_allocated/1024/1024/1024))\n    print(\"Project allocated storage GB: {}\".format(project_storage_bytes_allocated/1024/1024/1024))\nelse:\n    print(\"Project allocated vCPUs: 0\")\n    print(\"Project allocated memory GB: 0\")\n    print(\"Project allocated storage GB: 0\")\n#endregion get project allocated resources\n\n#region figure out if request complies with quotas\n#compute resources available in the project (quota - allocated)\nproject_available_vcpus = int(project_cpu_quota[0]) - project_cpu_allocated\nprint(\"Project available vCPUs: {}\".format(project_available_vcpus))\nproject_available_memory_bytes = int(project_memory_bytes_quota[0]) - project_memory_bytes_allocated\nprint(\"Project available memory bytes: {}\".format(project_available_memory_bytes))\nproject_available_storage_bytes = int(project_storage_bytes_quota[0]) - project_storage_bytes_allocated\nprint(\"Project available storage bytes: {}\".format(project_available_storage_bytes))\n\n#determine if there are enough resource available to process the request\nif (project_available_vcpus - required_vcpus_count) <= 0:\n    print(\"There aren't enough resources left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_memory_bytes - required_vram_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_storage_bytes - required_storage_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelse:\n    print(\"Project resources quota can accomodate this request.\")\n    exit(0)\n#endregion figure out if request complies with quotas\n\n#endregion main execution\n\n"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "PcCheckProjectQuota"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "ce68065e-b183-48dc-b99b-0aaf1e13381c",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonAddWorkerNode\n# description:  Adds worker node(s) to an existing Karbon managed k8s cluster. Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   add_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nadd_worker_node_count = int(\"@@{add_worker_node_count}@@\")\ncluster_name = \"@@{cluster_name}@@\"\nworker_node_pool = \"@@{cluster_name}@@\" + \"-worker-node-pool\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\npayload = {\n  \"count\": add_worker_node_count\n}\nmethod = 'POST'\nurl = \"https://{}:9440/karbon/v1-alpha.1/k8s/clusters/{}/node-pools/{}/add-nodes\".format(\n    prism_central_ip,\n    cluster_name,\n    worker_node_pool,\n)\n#endregion prepare api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to add Worker Node was successful\")\nprint(json.loads(resp.content))\nadd_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(add_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,add_task_uuid)\n\nexit(0)\n#endregion make api call"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonAddWorkerNode"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "6fc6e4cc-bc23-4a8f-bbdf-9888d0242181",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=1fece5ec_runbook; uuid=a3008208-bcd9-4d1e-9d9f-9785255b6c25}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "UpdateVmProject"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "a0deee72-9819-4b3b-91af-6895ec3ba92e",
                "state": "ACTIVE",
                "variable_list": [
                  {
                    "regex": {
                      "should_validate": false,
                      "value": "^[\\d]*$"
                    },
                    "val_type": "INT",
                    "is_mandatory": false,
                    "description": "",
                    "data_type": "BASE",
                    "message_list": [],
                    "uuid": "51707c14-04bf-4d68-80a9-dd855b0e110c",
                    "value": "1",
                    "label": "Nb of worker nodes to add",
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "type": "LOCAL",
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    },
                    "name": "add_worker_node_count"
                  }
                ],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "6f43296c_dag",
                  "uuid": "2ab60d03-f165-4652-b8c9-e2c6b1b3efe7"
                },
                "name": "876ef50a_runbook"
              }
            },
            {
              "description": "",
              "message_list": [],
              "uuid": "0c16607f-1459-48ce-a7d0-802be2db6b12",
              "name": "Remove Worker Node",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "user",
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "9f7968ca-7e56-4631-81b8-c535aec624d5",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonRemoveWorkerNode; uuid=b100dab9-fb17-4a93-8ef4-dee8f35b3917}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "569dfdac_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "b100dab9-fb17-4a93-8ef4-dee8f35b3917",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonRemoveWorkerNode\n# description:  Removes worker node(s) from an existing Karbon managed k8s cluster. Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   remove_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nremove_worker_node_count = int(\"@@{remove_worker_node_count}@@\")\ncluster_name = \"@@{cluster_name}@@\"\nworker_node_pool = \"@@{cluster_name}@@\" + \"-worker-node-pool\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                return task_status_details\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\npayload = {\n  \"count\": remove_worker_node_count\n}\nmethod = 'POST'\nurl = \"https://{}:9440/karbon/v1-alpha.1/k8s/clusters/{}/node-pools/{}/remove-nodes\".format(\n    prism_central_ip,\n    cluster_name,\n    worker_node_pool,\n)\n#endregion prepapre api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to remove Worker Node was successful\")\nprint(json.loads(resp.content))\nremove_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(remove_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,remove_task_uuid)\n\nexit(0)\n#endregion make api call"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonRemoveWorkerNode"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "68753daa-d446-4e7f-9790-1c212bbee5d6",
                "state": "ACTIVE",
                "variable_list": [
                  {
                    "regex": {
                      "should_validate": false,
                      "value": "^[\\d]*$"
                    },
                    "val_type": "INT",
                    "is_mandatory": false,
                    "description": "",
                    "data_type": "BASE",
                    "message_list": [],
                    "uuid": "5377529b-2844-44c0-bd12-527dd97ce66d",
                    "value": "1",
                    "label": "Nb of worker nodes to remove",
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "type": "LOCAL",
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    },
                    "name": "remove_worker_node_count"
                  }
                ],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "569dfdac_dag",
                  "uuid": "9f7968ca-7e56-4631-81b8-c535aec624d5"
                },
                "name": "bd846b3b_runbook"
              }
            },
            {
              "description": "",
              "message_list": [],
              "uuid": "4ff5e9ae-f37c-4ddc-b897-8291a9962026",
              "name": "Get kubeconfig file",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "user",
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "a7f90e71-9a90-46d3-bca3-5676b9f248b5",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SendKubeconfig; uuid=acfb8707-0bf9-42bf-bd27-eaba49d0e5d4}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "548dfee9_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "acfb8707-0bf9-42bf-bd27-eaba49d0e5d4",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=55bdcacb_runbook; uuid=cabb5317-1316-4b7c-b8f6-94fea48389b1}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SendKubeconfig"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "b240fab0-9788-4a41-91af-acd4d09cc955",
                "state": "ACTIVE",
                "variable_list": [
                  {
                    "regex": {
                      "should_validate": true,
                      "value": "(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])"
                    },
                    "val_type": "STRING",
                    "is_mandatory": true,
                    "description": "The kubeconfig file will be sent to this email address.",
                    "data_type": "BASE",
                    "message_list": [],
                    "uuid": "024f24a0-77ad-4ba7-adb4-6ac099491a65",
                    "value": "stephane.bourdeaud@nutanix.com",
                    "label": "Your email address",
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "type": "LOCAL",
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    },
                    "name": "email_address"
                  }
                ],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "548dfee9_dag",
                  "uuid": "a7f90e71-9a90-46d3-bca3-5676b9f248b5"
                },
                "name": "124dab53_runbook"
              }
            },
            {
              "description": "",
              "message_list": [],
              "uuid": "36ff01f0-690c-4656-9d83-98b07e03789f",
              "name": "Get available upgrades",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "user",
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "695dc29a-3bac-4b89-9252-be41ae828d82",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonGetAvailableUpdates; uuid=b0b29874-7a24-4d9f-adf3-f9e1f488a690}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "0b6c6c05_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "b0b29874-7a24-4d9f-adf3-f9e1f488a690",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonGetK8sUpdates\n# description:  Retrieves list of available upgrade versions for the given cluster name. \n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   k8s_versions and os_versions (as list)\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1-beta.1/k8s/clusters/available-updates\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers)\n#* output vars defined here\n#k8s_versions_list = [clusters['ntnx_k8s_releases'] for clusters in resp if clusters['name'] == cluster_name]\n#k8s_versions = [version_number['version'] for version_number in version for version in k8s_versions_list]\n\nk8s_versions = []\nos_versions = []\n\nfor clusters in json.loads(resp.content):\n    #print(\"clusters: {}\".format(clusters))\n    if clusters['name'] == cluster_name:\n        if clusters['ntnx_k8s_releases']:\n            for k8s_version in clusters['ntnx_k8s_releases']:\n                #print(\"versions: {}\".format(versions))\n                k8s_versions.append(k8s_version['version'])\n        if clusters['node_os_images']:\n            for os_version in clusters['node_os_images']:\n                os_versions.append(os_version['version'])\n\n\nprint(\"k8s_versions={}\".format(json.dumps(k8s_versions)))\nprint(\"os_versions={}\".format(json.dumps(os_versions)))\n\nexit(0)\n#endregion make the api call"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonGetAvailableUpdates"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "3f426908-988f-448f-af89-4056867de3ba",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "0b6c6c05_dag",
                  "uuid": "695dc29a-3bac-4b89-9252-be41ae828d82"
                },
                "name": "5f14601c_runbook"
              }
            },
            {
              "description": "",
              "message_list": [],
              "uuid": "b599e716-b2b7-4973-a2d7-3077e4ee645c",
              "name": "Upgrade k8s version",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "user",
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "9c30b9a0-4919-417b-95cf-d9a5f6ca9296",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonUpgradeK8s; uuid=5f78ff8e-ac72-4fda-a308-2fcf3e838678}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "f9ebd532_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "5f78ff8e-ac72-4fda-a308-2fcf3e838678",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220113\n# task_name:    KarbonUpgradeK8s\n# description:  Upgrades the target Karbon K8s cluster to the desired version\n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   upgrade_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nkarbon_cluster_uuid = \"@@{karbon_cluster_uuid}@@\"\ncluster_name = \"@@{cluster_name}@@\"\nk8s_version = \"@@{k8s_version}@@\"\ntarget_k8s_version = \"@@{target_k8s_version}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout = 30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\npayload = {\n    \"upgrade_config\": {\n        \"pkg_version\": target_k8s_version\n    },\n    \"cluster_uuid\": karbon_cluster_uuid,\n    \"drain-policy\": \"kAlways\",\n    \"drain-timeout\": \"180s\"\n}\nmethod = 'POST'\nurl = \"https://{}:9440/karbon/acs/k8s/cluster/{}/k8s_upgrade\".format(\n    prism_central_ip,\n    karbon_cluster_uuid\n)\n#endregion prepare api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Upgrading Kubernetes cluster {} from version {} to version {}\".format(cluster_name,k8s_version,target_k8s_version))\nprint(json.loads(resp.content))\nupgrade_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(upgrade_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,upgrade_task_uuid)\n\nexit(0)\n#endregion make api call"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonUpgradeK8s"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "9c5d3faa-792f-4bfd-a0a7-5b5917d18984",
                "state": "ACTIVE",
                "variable_list": [
                  {
                    "regex": {},
                    "val_type": "STRING",
                    "is_mandatory": true,
                    "description": "You can use the \"Get available upgrades\" action to find out which versions this cluster is eligle for.",
                    "data_type": "BASE",
                    "message_list": [],
                    "uuid": "a6b8d37f-a291-4c08-961c-fb91f0018251",
                    "value": "1.20.9-0",
                    "label": "Which version of k8s do you want to upgrade to?",
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "type": "LOCAL",
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    },
                    "name": "target_k8s_version"
                  }
                ],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "f9ebd532_dag",
                  "uuid": "9c30b9a0-4919-417b-95cf-d9a5f6ca9296"
                },
                "name": "e63f4359_runbook"
              }
            },
            {
              "description": "",
              "message_list": [],
              "uuid": "66673df8-8c2a-4222-8d18-3f773dc137b3",
              "name": "Upgrade node host images",
              "state": "ACTIVE",
              "critical": false,
              "attrs": {},
              "type": "user",
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "07baa6bb-f9e8-480d-a39a-621f5ba09767",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonGetImageUuid; uuid=adeebf65-335e-4f66-8a47-c15cb6be2965}",
                      "@{kind=app_task; name=KarbonUpgradeHosts; uuid=78cb8378-00d7-4bff-bbc6-fe6f04f23bc6}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "6b4814a0_dag"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SET_VARIABLE",
                    "uuid": "adeebf65-335e-4f66-8a47-c15cb6be2965",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonGetImageUuid\n# description:  Gets the uuid of the specified host image version. \n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   image_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ntarget_image_version = \"@@{target_image_version}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/acs/image/list\".format(prism_central_ip)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers)\n#* output vars defined here\nimages = json.loads(resp.content)\n\nfor image in images:\n    if image['version'] == target_image_version:\n        image_uuid = image['image_uuid']\n        print (\"image_uuid={}\".format(image_uuid))\n        exit(0)\n\nprint (\"Could not find image uuid for image version {}\".format(target_image_version))\nexit(1)\n#endregion make the api call",
                      "eval_variables": "image_uuid",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonGetImageUuid"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "EXEC",
                    "uuid": "78cb8378-00d7-4bff-bbc6-fe6f04f23bc6",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "script_type": "static",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220113\n# task_name:    KarbonUpgradeHosts\n# description:  Upgrades the target Karbon K8s cluster nodes to the desired host image version\n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   upgrade_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nkarbon_cluster_uuid = \"@@{karbon_cluster_uuid}@@\"\ncluster_name = \"@@{cluster_name}@@\"\nimage_uuid = \"@@{image_uuid}@@\"\ntarget_image_version = \"@@{target_image_version}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout = 30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\npayload = {\n    \"image_uuid\": image_uuid,\n    \"cluster_uuid\": karbon_cluster_uuid,\n    \"drain-policy\": \"kAlways\",\n    \"drain-timeout\": \"180s\"\n}\nmethod = 'POST'\nurl = \"https://{}:9440/karbon/acs/k8s/cluster/{}/upgrade\".format(\n    prism_central_ip,\n    karbon_cluster_uuid\n)\n#endregion prepare api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Upgrading Kubernetes cluster {} to host image version {}\".format(cluster_name,target_image_version))\nprint(json.loads(resp.content))\nupgrade_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(upgrade_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,upgrade_task_uuid)\n\nexit(0)\n#endregion make api call"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "KarbonUpgradeHosts"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "1d6b8f83-4d4c-4175-944e-46777c89f765",
                "state": "ACTIVE",
                "variable_list": [
                  {
                    "regex": {},
                    "val_type": "STRING",
                    "is_mandatory": false,
                    "description": "You can use the \"Get available upgrades\" action to find out which host images this cluster is eligible for.",
                    "data_type": "BASE",
                    "message_list": [],
                    "uuid": "84d421e1-f320-4f17-9c39-a4fa8fa7d391",
                    "value": "ntnx-1.1",
                    "label": "Which host image version do you want to upgrade to?",
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "type": "LOCAL",
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    },
                    "name": "target_image_version"
                  }
                ],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "6b4814a0_dag",
                  "uuid": "07baa6bb-f9e8-480d-a39a-621f5ba09767"
                },
                "name": "501699c7_runbook"
              }
            },
            {
              "description": "System action for creating an application",
              "message_list": [],
              "uuid": "5351ab4f-7606-4f46-ba4b-3a31dba4b992",
              "name": "action_create",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_profile",
                      "name": "Default",
                      "uuid": "3288a65d-a793-48d7-801d-59f5cc1db137"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "fbba6c6a-00f8-4d03-b034-209c1fc1ed01",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__DE_Provision_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a; uuid=ba104b4a-f4d2-4c57-b085-b490eca43004}",
                      "@{kind=app_task; name=SYS_GEN__create_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=74df0c2a-186a-4823-a147-536cd1abba13}",
                      "@{kind=app_task; name=SYS_GEN__install_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=496cdf2e-d025-46d7-9faa-f909e0480e63}",
                      "@{kind=app_task; name=SYS_GEN__create_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=527d6605-4ccd-430e-bbed-fe78278d72c1}",
                      "@{kind=app_task; name=SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=5f02a377-2048-461f-9769-a4a54b519573}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "   ",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_blueprint_deployment",
                      "name": "1c2a7ea2_deployment",
                      "uuid": "9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CREATE_DEPLOYMENT_ELEMENT",
                    "uuid": "ba104b4a-f4d2-4c57-b085-b490eca43004",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DE_Provision_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "74df0c2a-186a-4823-a147-536cd1abba13",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=b14c0748-81f0-482d-93de-4b0395d88225}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__create_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "496cdf2e-d025-46d7-9faa-f909e0480e63",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=9bb84f65-0257-4e21-a3e7-af2cebff2ed8}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__install_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "527d6605-4ccd-430e-bbed-fe78278d72c1",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=82d0a3f5_runbook; uuid=0cf026a5-60c1-44d6-9cae-fb0f0299a2fe}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__create_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "5f02a377-2048-461f-9769-a4a54b519573",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=60814c0f_runbook; uuid=7e1ffbb5-989c-4a4a-8194-e7f794fffe72}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "112bcae5-b92e-4a46-80e9-d9d43183868f",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137",
                  "uuid": "fbba6c6a-00f8-4d03-b034-209c1fc1ed01"
                },
                "name": "SYS_GEN__Runbook_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
              }
            },
            {
              "description": "System action for starting an application",
              "message_list": [],
              "uuid": "e8e75c26-9d27-4823-ae15-b3c7b6aaf8aa",
              "name": "action_start",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_profile",
                      "name": "Default",
                      "uuid": "3288a65d-a793-48d7-801d-59f5cc1db137"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "dad7d420-6a10-48e0-af62-30621449e0e3",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__start_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=495d5ffa-a55a-4df4-a32e-1b366b6c0b93}",
                      "@{kind=app_task; name=SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=2562ffae-ba7f-4913-b4e5-42f56cecdf82}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "495d5ffa-a55a-4df4-a32e-1b366b6c0b93",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=e875c072-d6cf-4ff7-bcbe-b3bf9d99039d}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__start_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "2562ffae-ba7f-4913-b4e5-42f56cecdf82",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=60814c0f_runbook; uuid=7e1ffbb5-989c-4a4a-8194-e7f794fffe72}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "ab8a48ab-a9ce-4ecf-b211-7e39cd1bbfe6",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137",
                  "uuid": "dad7d420-6a10-48e0-af62-30621449e0e3"
                },
                "name": "SYS_GEN__Runbook_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
              }
            },
            {
              "description": "System action for restarting an application",
              "message_list": [],
              "uuid": "80c84b2c-bb96-46f8-a8f5-569c8edecee6",
              "name": "action_restart",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_profile",
                      "name": "Default",
                      "uuid": "3288a65d-a793-48d7-801d-59f5cc1db137"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "769dfa77-dbb3-480f-a5ac-c7232b752f8c",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__restart_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=d8831542-2e89-4f44-8483-7ce6a3eaf7e1}",
                      "@{kind=app_task; name=SYS_GEN__restart_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=cbc8bf92-c084-4971-aa76-057ab981d0c2}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "d8831542-2e89-4f44-8483-7ce6a3eaf7e1",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=e81c8176-68ad-40ba-baea-036c4fff63f3}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__restart_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "cbc8bf92-c084-4971-aa76-057ab981d0c2",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=91fdabc1_runbook; uuid=0789dd92-4083-484b-b624-e1bf36f1f6d4}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__restart_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "0b55954a-4b12-4148-8519-b873ae713848",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137",
                  "uuid": "769dfa77-dbb3-480f-a5ac-c7232b752f8c"
                },
                "name": "SYS_GEN__Runbook_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
              }
            },
            {
              "description": "System action for stopping an application",
              "message_list": [],
              "uuid": "2d3e9c5e-9a8f-4f83-b21e-020673b177dd",
              "name": "action_stop",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_profile",
                      "name": "Default",
                      "uuid": "3288a65d-a793-48d7-801d-59f5cc1db137"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "4da03063-4625-41ef-a7d4-0dce0f7f71d1",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=3055754f-5c0c-4320-b171-bde010790f7e}",
                      "@{kind=app_task; name=SYS_GEN__stop_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=56a2f168-8c71-4789-875b-e86ffc9b2dbc}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "3055754f-5c0c-4320-b171-bde010790f7e",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=46f8c648_runbook; uuid=80d4576e-128c-4570-95a1-8370c9a7ccdb}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "56a2f168-8c71-4789-875b-e86ffc9b2dbc",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=c4242ebd-c802-4bda-9e87-a6f074c30dbb}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__stop_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "ab7dec94-744d-44cd-903b-320ac365b34b",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137",
                  "uuid": "4da03063-4625-41ef-a7d4-0dce0f7f71d1"
                },
                "name": "SYS_GEN__Runbook_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
              }
            },
            {
              "description": "System action for deleting an application. Deletes created VMs as well",
              "message_list": [],
              "uuid": "9c7784fd-bc88-4fb5-8afe-75b8602e796b",
              "name": "action_delete",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_profile",
                      "name": "Default",
                      "uuid": "3288a65d-a793-48d7-801d-59f5cc1db137"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "46a2df20-0d27-41b7-9be6-1b047c9b6689",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=a4c878d1-9e87-4455-aa75-c2499340cdf8}",
                      "@{kind=app_task; name=SYS_GEN__delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=ce80e781-455b-4658-be61-376431dde1c8}",
                      "@{kind=app_task; name=SYS_GEN__uninstall_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=52c6b287-e291-4ba9-a93b-27d56a03d958}",
                      "@{kind=app_task; name=SYS_GEN__delete_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=3f52556d-5d5d-4f1d-917c-03a6cfdec08a}",
                      "@{kind=app_task; name=SYS_GEN__DE_Delete_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a; uuid=bed657c5-ccff-4a07-9f4a-3147704e7162}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "   ",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "a4c878d1-9e87-4455-aa75-c2499340cdf8",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=46f8c648_runbook; uuid=80d4576e-128c-4570-95a1-8370c9a7ccdb}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "ce80e781-455b-4658-be61-376431dde1c8",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=2cb579b6_runbook; uuid=b9693aa2-8909-4264-9c30-117ac9625899}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "52c6b287-e291-4ba9-a93b-27d56a03d958",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=cc854ca9-1e8c-4dbc-ba5d-169646661524}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__uninstall_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "3f52556d-5d5d-4f1d-917c-03a6cfdec08a",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=cb8e4c3e-3f00-4998-9bad-0346ab457d12}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__delete_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_blueprint_deployment",
                      "name": "1c2a7ea2_deployment",
                      "uuid": "9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DELETE_DEPLOYMENT_ELEMENT",
                    "uuid": "bed657c5-ccff-4a07-9f4a-3147704e7162",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DE_Delete_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "aaab3458-adff-4fa3-827a-8303a2ba627f",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137",
                  "uuid": "46a2df20-0d27-41b7-9be6-1b047c9b6689"
                },
                "name": "SYS_GEN__Runbook_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
              }
            },
            {
              "description": "System action for deleting an application. Does not delete created VMs",
              "message_list": [],
              "uuid": "7a233749-7aa4-48a8-8c3a-abb3d565de03",
              "name": "action_soft_delete",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_profile",
                      "name": "Default",
                      "uuid": "3288a65d-a793-48d7-801d-59f5cc1db137"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "2e0cf4af-1a4d-41ae-b128-0eb2402dfdda",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__soft_delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=e41aaf26-4eda-48d5-b12d-6d375ce448fd}",
                      "@{kind=app_task; name=SYS_GEN__Package_Element_Delete_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=e81ce8f0-ec14-4bca-94d3-e491c0a8eaa6}",
                      "@{kind=app_task; name=SYS_GEN__soft_delete_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=ab290d02-06a1-4635-95f8-33148af12b53}",
                      "@{kind=app_task; name=SYS_GEN__DE_Soft_Delete_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a; uuid=45498de1-8692-440d-8d15-a8fdf3ca8d91}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "  ",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "e41aaf26-4eda-48d5-b12d-6d375ce448fd",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=1a689ca6-aa5c-4825-8255-92860f6d14b2}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__soft_delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SOFT_DELETE_ELEMENT",
                    "uuid": "e81ce8f0-ec14-4bca-94d3-e491c0a8eaa6",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Package_Element_Delete_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_substrate",
                      "name": "ManagementLinuxVM",
                      "uuid": "2dd2b1d4-a3e2-4ca5-843f-48746a0fedec"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "ab290d02-06a1-4635-95f8-33148af12b53",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "deployment_reference": "@{kind=app_blueprint_deployment; name=1c2a7ea2_deployment; uuid=9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a}",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec; uuid=a956d0ed-b881-4568-b09f-80b58efbee07}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__soft_delete_CRb_Substrate_2dd2b1d4_a3e2_4ca5_843f_48746a0fedec"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_blueprint_deployment",
                      "name": "1c2a7ea2_deployment",
                      "uuid": "9d7ffefe-a7c5-4772-b1fc-b9d0eec98e7a"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SOFT_DELETE_DEPLOYMENT_ELEMENT",
                    "uuid": "45498de1-8692-440d-8d15-a8fdf3ca8d91",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DE_Soft_Delete_9d7ffefe_a7c5_4772_b1fc_b9d0eec98e7a"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "47292b03-e4de-4d26-993f-63ce68147133",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Application_3288a65d_a793_48d7_801d_59f5cc1db137",
                  "uuid": "2e0cf4af-1a4d-41ae-b128-0eb2402dfdda"
                },
                "name": "SYS_GEN__Runbook_Application_3288a65d_a793_48d7_801d_59f5cc1db137"
              }
            }
          ],
          "message_list": [],
          "uuid": "3288a65d-a793-48d7-801d-59f5cc1db137",
          "dependency_list": [],
          "snapshot_config_list": [],
          "state": "ACTIVE",
          "patch_list": [],
          "restore_config_list": [],
          "variable_list": [
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "8a8ae99a-ff59-4c35-b489-538f8f7d2988",
              "value": "127.0.0.1",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "prism_central_ip"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "53f77b25-627e-4005-a15a-e431adb3a027",
              "value": "10.40.64.35",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "smtp_server"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "a60cc57f-76c8-4e3d-875e-535c9ff31dca",
              "value": "stephane.bourdeaud@nutanix.com",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "email_sender"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "UUID of the AHV managed network used to deploy this cluster.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "83d15b4c-35d9-4de4-8255-3a4880e56b88",
              "value": "7c19b244-bcc7-4186-9f09-84db45dec57f",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "subnet_uuid"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "UUID of the AHV cluster used to deploy this cluster.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "a478aac9-74a7-444a-9086-cf4763bf226c",
              "value": "00058163-33b2-4359-0000-0000000167e4",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "pe_cluster_uuid"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Name of the storage container used to provision k8s nodes and their vdisks.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "92963185-3a75-4fc6-85b6-2e18eb19fd26",
              "value": "default-container-92132",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {},
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "storage_container_name"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Version of the host OS image used to provision k8s nodes by Karbon.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "a7838964-6bd5-45aa-a66b-7c71159c796c",
              "value": "ntnx-1.1",
              "label": "",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {},
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "image_name"
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "This is the IPv4 CIDR range that will be used for the overlay network used by the pods.\nThe default is 172.20.0.0/16. This can be the same for multiple different k8s clusters if pods from different clusters don't need to talk to each other directly.\nThis is only used if your selected Calico as the CNI.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "22cfe907-b665-4712-b8cb-40d54afa2236",
              "value": "172.20.0.0/16",
              "label": "Calico CIDR Range",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "calico_cidr"
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Required for Active-Active setups.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "ce36bb64-ac30-408f-b6bb-1bfcf5c1e597",
              "value": "",
              "label": "External Load Balancer IP address",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {},
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "external_lb"
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Only required for Active-Active setups.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "373072ec-66a7-413b-9055-e91fda4981cb",
              "value": "",
              "label": "Other Kubernetes VIP",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "master_vip2"
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Only required for Active-Passive and Active-Active setups.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "bfc7c5c1-2f6a-4030-a7a3-3929867932d7",
              "value": "",
              "label": "Kubernetes Cluster VIP",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "master_vip"
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "This is the IPv4 CIDR range that will be used for the overlay network used by the pods.\nThe default is 172.20.0.0/16. This can be the same for multiple different k8s clusters if pods from different clusters don't need to talk to each other directly.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "8387679b-4c06-4a13-83dc-2536bc6ce071",
              "value": "172.20.0.0/16",
              "label": "Pod CIDR Range",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "pod_cidr_range"
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "This is the IPv4 CIDR range that will be used for the service overlay network between the k8s nodes.\nThe default is 172.19.0.0/16. This can be the same for multiple different k8s clusters.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "2782fd3b-d8f6-4ac7-804d-5b3331abb99c",
              "value": "172.19.0.0/16",
              "label": "Service CIDR Range",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "service_cidr_range"
            },
            {
              "regex": {
                "should_validate": false,
                "value": "^[\\d]*$"
              },
              "val_type": "INT",
              "is_mandatory": true,
              "description": "Quantity of worker nodes in the k8s cluster.\nDefault is the minimum of 1.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "aa447fbb-c158-402e-b9a9-3e2f84090abf",
              "value": "1",
              "label": "Qty of Worker Nodes",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "worker_node_qty"
            },
            {
              "regex": {
                "should_validate": false,
                "value": "^[\\d]*$"
              },
              "val_type": "INT",
              "is_mandatory": true,
              "description": "Size (in GiB) of vDisk for each worker node.\nDefault is a minimum of 120 GiB.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "ec0ce6e4-9163-4cb3-a34c-c3a764791c96",
              "value": "120",
              "label": "Worker Nodes vDisk GiB",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "worker_node_disk_size"
            },
            {
              "regex": {
                "should_validate": false,
                "value": "^[\\d]*$"
              },
              "val_type": "INT",
              "is_mandatory": true,
              "description": "Quantity (in GiB) of vRAM for each worker node.\nDefault is a minimum of 8 GiB.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "b7d3051b-092e-451c-8894-99cae82e3705",
              "value": "8",
              "label": "Worker Nodes vRAM GiB",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "worker_node_memory"
            },
            {
              "regex": {
                "should_validate": false,
                "value": "^[\\d]*$"
              },
              "val_type": "INT",
              "is_mandatory": true,
              "description": "Number of vCPUs for each worker nodes.\nDefault is a minimum of 8 vCPUs.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "55345c47-b25d-4bc8-a5be-5fc0ccff327e",
              "value": "8",
              "label": "Worker Nodes vCPU Qty",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "worker_node_cpu"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "6d42337e-0586-49fa-80a1-dc220ea43782",
              "value": "Flannel",
              "label": "Kubernetes CNI",
              "state": "ACTIVE",
              "attrs": {
                "type": "LOCAL"
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": [
                  "Flannel",
                  "Calico"
                ]
              },
              "name": "k8s_cni"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "Single Master: for non-production environments\nActive-Passive: for production environments without an external load balancer\nActive-Active: for production environments with a pre-configured external load balancer",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "7faaf380-09e5-494b-9564-b8287a6c89d5",
              "value": "Single Master",
              "label": "Master node configuration",
              "state": "ACTIVE",
              "attrs": {
                "type": "LOCAL"
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": [
                  "Single Master",
                  "Active-Passive",
                  "Active-Active"
                ]
              },
              "name": "master_config"
            },
            {
              "regex": {},
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "91b4126b-95ea-490f-b91a-6013aeed7488",
              "value": "1.20.9-0",
              "label": "Kubernetes version",
              "state": "ACTIVE",
              "attrs": {
                "type": "LOCAL"
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": [
                  "1.20.9-0",
                  "1.19.13-0",
                  "1.18.20-0",
                  "1.17.13-0"
                ]
              },
              "name": "k8s_version"
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^((?!_).)*$"
              },
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "This is the name that will be displayed in the Karbon cluster manager.  It cannot contain any underscore (_) character.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "3fa80c72-33fb-48f5-8dfc-a2449810e5fa",
              "value": "steph-karbon-test-cluster",
              "label": "Kubernetes Cluster Name",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "cluster_name"
            },
            {
              "regex": {
                "should_validate": true,
                "value": "(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])"
              },
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "This will be used to send you information about the provisioned k8s cluster.",
              "data_type": "BASE",
              "message_list": [],
              "uuid": "95d21dac-f630-4f61-ae1a-f66511a1a6c4",
              "value": "stephane.bourdeaud@nutanix.com",
              "label": "Your email address",
              "state": "ACTIVE",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "type": "LOCAL",
              "options": {
                "type": "PREDEFINED",
                "choices": []
              },
              "name": "requester_email"
            }
          ],
          "name": "Default"
        }
      ],
      "published_service_definition_list": [],
      "default_credential_local_reference": {
        "kind": "app_credential",
        "name": "prism_central",
        "uuid": "2b72530b-dc51-4074-b42d-e84bd60b4a1a"
      },
      "package_definition_list": [
        {
          "description": "",
          "action_list": [
            {
              "description": "System action for installing an application",
              "message_list": [],
              "uuid": "7c028ab3-5e3d-4177-b5f1-7a4315cdb9dc",
              "name": "action_install",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "cfb7b58b-ae45-4d85-9e30-7c442638a1f1",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__Install_Crb_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=b8a59845-96ac-4143-bb94-7e4c43ed46fd}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CUSTOM_PACKAGE_INSTALL",
                    "uuid": "b8a59845-96ac-4143-bb94-7e4c43ed46fd",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "install_runbook": "@{task_definition_list=System.Object[]; description=; message_list=System.Object[]; uuid=04009b2b-06c0-40a0-8487-83ae8091f393; state=ACTIVE; variable_list=System.Object[]; main_task_local_reference=; name=96f39da5_runbook}",
                      "type": "",
                      "upgrade_runbook": "",
                      "uninstall_runbook": "@{task_definition_list=System.Object[]; description=; message_list=System.Object[]; uuid=e49c73c4-b633-4aa5-8ca0-b3ad10c0cdc6; state=ACTIVE; variable_list=System.Object[]; main_task_local_reference=; name=2994e4d9_runbook}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Install_Crb_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "9bb84f65-0257-4e21-a3e7-af2cebff2ed8",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2",
                  "uuid": "cfb7b58b-ae45-4d85-9e30-7c442638a1f1"
                },
                "name": "SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
              }
            },
            {
              "description": "System action for creating an application",
              "message_list": [],
              "uuid": "2e2842d4-dc5d-4f3a-ad1e-4b40b1d964a9",
              "name": "action_create",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "e62abfe1-efc0-4de9-b7ed-7aa3db8c2f37",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__install_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=c2fffa90-9994-4d7e-bdb7-5baece14af75}",
                      "@{kind=app_task; name=SYS_GEN__create_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=e79f9ddd-cedb-46c2-8b0a-87edf3119d62}",
                      "@{kind=app_task; name=SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=9b8b986a-f133-41f6-a4d2-9c8f730ef412}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": " ",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "c2fffa90-9994-4d7e-bdb7-5baece14af75",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=9bb84f65-0257-4e21-a3e7-af2cebff2ed8}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__install_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "e79f9ddd-cedb-46c2-8b0a-87edf3119d62",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=82d0a3f5_runbook; uuid=0cf026a5-60c1-44d6-9cae-fb0f0299a2fe}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__create_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "9b8b986a-f133-41f6-a4d2-9c8f730ef412",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=60814c0f_runbook; uuid=7e1ffbb5-989c-4a4a-8194-e7f794fffe72}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "ab6cbd16-e18a-44ea-90b7-da39637554b1",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2",
                  "uuid": "e62abfe1-efc0-4de9-b7ed-7aa3db8c2f37"
                },
                "name": "SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
              }
            },
            {
              "description": "System action for uninstalling an application",
              "message_list": [],
              "uuid": "112c0513-f307-41e7-b182-2384916d671b",
              "name": "action_uninstall",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "861910ee-e91a-47d2-9035-54f3ea2e8e7e",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__Uninstall_Crb_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=960107f4-5909-48c0-a493-7d1924b4429d}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CUSTOM_PACKAGE_UNINSTALL",
                    "uuid": "960107f4-5909-48c0-a493-7d1924b4429d",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "install_runbook": "@{task_definition_list=System.Object[]; description=; message_list=System.Object[]; uuid=04009b2b-06c0-40a0-8487-83ae8091f393; state=ACTIVE; variable_list=System.Object[]; main_task_local_reference=; name=96f39da5_runbook}",
                      "type": "",
                      "upgrade_runbook": "",
                      "uninstall_runbook": "@{task_definition_list=System.Object[]; description=; message_list=System.Object[]; uuid=e49c73c4-b633-4aa5-8ca0-b3ad10c0cdc6; state=ACTIVE; variable_list=System.Object[]; main_task_local_reference=; name=2994e4d9_runbook}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Uninstall_Crb_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "cc854ca9-1e8c-4dbc-ba5d-169646661524",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2",
                  "uuid": "861910ee-e91a-47d2-9035-54f3ea2e8e7e"
                },
                "name": "SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
              }
            },
            {
              "description": "System action for deleting an application. Deletes created VMs as well",
              "message_list": [],
              "uuid": "0b3f437e-bf5d-4161-ba4a-64b76078afe9",
              "name": "action_delete",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "8f46d7a8-dba6-48c8-aa9c-3895c58082b3",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=51ca0764-397f-45c1-8895-1d440d90f0de}",
                      "@{kind=app_task; name=SYS_GEN__delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=a364968c-be48-41a4-a96f-0a360b07edc2}",
                      "@{kind=app_task; name=SYS_GEN__uninstall_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=158f1235-5217-4432-884d-f8fe98c2bc2d}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": " ",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "51ca0764-397f-45c1-8895-1d440d90f0de",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=46f8c648_runbook; uuid=80d4576e-128c-4570-95a1-8370c9a7ccdb}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "a364968c-be48-41a4-a96f-0a360b07edc2",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=2cb579b6_runbook; uuid=b9693aa2-8909-4264-9c30-117ac9625899}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "158f1235-5217-4432-884d-f8fe98c2bc2d",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=cc854ca9-1e8c-4dbc-ba5d-169646661524}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__uninstall_CRb_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "b94c667b-7409-45a6-b18e-b020139b5b08",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2",
                  "uuid": "8f46d7a8-dba6-48c8-aa9c-3895c58082b3"
                },
                "name": "SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
              }
            },
            {
              "description": "System action for deleting an application. Does not delete created VMs",
              "message_list": [],
              "uuid": "32e10546-3db1-4cba-bb6b-1fe9781f6879",
              "name": "action_soft_delete",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "e59397af-6e45-486e-9a7f-b27fa0efcef5",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__soft_delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=b793670f-9916-4756-8852-e3ca1637fb3a}",
                      "@{kind=app_task; name=SYS_GEN__Package_Element_Delete_b17d1c3e_3491_47a4_802b_ea7c2c28bec2; uuid=2d240e48-7a99-4d43-8bcf-744e1c38c791}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "b793670f-9916-4756-8852-e3ca1637fb3a",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=SYS_GEN__Runbook_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=1a689ca6-aa5c-4825-8255-92860f6d14b2}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__soft_delete_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "SOFT_DELETE_ELEMENT",
                    "uuid": "2d240e48-7a99-4d43-8bcf-744e1c38c791",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Package_Element_Delete_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "5a718656-b04b-4b28-8f19-2b2e25fc85d5",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2",
                  "uuid": "e59397af-6e45-486e-9a7f-b27fa0efcef5"
                },
                "name": "SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
              }
            },
            {
              "description": "System action for starting an application",
              "message_list": [],
              "uuid": "6e739919-1824-46f9-93ed-67be078708e5",
              "name": "action_start",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "f329ae25-21f0-451c-bdfb-245d46c01f9a",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=709b694f-8522-4d30-a666-18bb27e0ccf2}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "709b694f-8522-4d30-a666-18bb27e0ccf2",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=60814c0f_runbook; uuid=7e1ffbb5-989c-4a4a-8194-e7f794fffe72}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__start_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "23d4ccba-4acd-432f-aacb-d9044ce71ecd",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2",
                  "uuid": "f329ae25-21f0-451c-bdfb-245d46c01f9a"
                },
                "name": "SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
              }
            },
            {
              "description": "System action for restarting an application",
              "message_list": [],
              "uuid": "951632d9-94cb-4d9e-95a1-267aacadccd8",
              "name": "action_restart",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "83b934b1-0514-44c2-984f-b52bf98d2d17",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__restart_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=beb3c908-792a-4437-8094-459b1d8e33ac}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "beb3c908-792a-4437-8094-459b1d8e33ac",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=91fdabc1_runbook; uuid=0789dd92-4083-484b-b624-e1bf36f1f6d4}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__restart_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "13c68199-32a2-4bae-81b5-9a5366054328",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2",
                  "uuid": "83b934b1-0514-44c2-984f-b52bf98d2d17"
                },
                "name": "SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
              }
            },
            {
              "description": "System action for stopping an application",
              "message_list": [],
              "uuid": "e506f25c-fdb4-4240-addb-a453566b03a9",
              "name": "action_stop",
              "state": "ACTIVE",
              "critical": true,
              "attrs": {},
              "type": "system",
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_package",
                      "name": "Package1",
                      "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "DAG",
                    "uuid": "5a515d78-ffa2-45be-98f1-eb9a55ccb6ab",
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07; uuid=1664bfc0-48a7-4c46-90c4-56845f2942d6}"
                    ],
                    "state": "ACTIVE",
                    "attrs": {
                      "edges": "",
                      "type": "DAG"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService",
                      "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
                    },
                    "retries": "0",
                    "description": "",
                    "type": "CALL_RUNBOOK",
                    "uuid": "1664bfc0-48a7-4c46-90c4-56845f2942d6",
                    "child_tasks_local_reference_list": [],
                    "state": "ACTIVE",
                    "attrs": {
                      "inarg_list": "",
                      "type": "CALL_RUNBOOK",
                      "runbook_reference": "@{kind=app_runbook; name=46f8c648_runbook; uuid=80d4576e-128c-4570-95a1-8370c9a7ccdb}"
                    },
                    "timeout_secs": "0",
                    "inherit_target": false,
                    "message_list": [],
                    "variable_list": [],
                    "name": "SYS_GEN__stop_CRb_Service_b27e4680_02a6_4808_b991_74c245247d07"
                  }
                ],
                "description": "",
                "message_list": [],
                "uuid": "8befa22d-200e-4693-b294-a5ed429a927f",
                "state": "ACTIVE",
                "variable_list": [],
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "SYS_GEN__Composite_DAG_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2",
                  "uuid": "5a515d78-ffa2-45be-98f1-eb9a55ccb6ab"
                },
                "name": "SYS_GEN__Runbook_Package_b17d1c3e_3491_47a4_802b_ea7c2c28bec2"
              }
            }
          ],
          "message_list": [],
          "service_local_reference_list": [
            {
              "kind": "app_service",
              "name": "ManagementService",
              "uuid": "b27e4680-02a6-4808-b991-74c245247d07"
            }
          ],
          "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2",
          "state": "ACTIVE",
          "version": "",
          "editables": {},
          "type": "DEB",
          "options": {
            "install_runbook": {
              "task_definition_list": [
                {
                  "target_any_local_reference": {
                    "kind": "app_package",
                    "name": "Package1",
                    "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                  },
                  "retries": "0",
                  "description": "",
                  "type": "DAG",
                  "uuid": "4701f017-3d27-47e2-82ad-0db6529c53ec",
                  "child_tasks_local_reference_list": [],
                  "state": "ACTIVE",
                  "attrs": {
                    "edges": [],
                    "type": ""
                  },
                  "timeout_secs": "0",
                  "inherit_target": false,
                  "message_list": [],
                  "variable_list": [],
                  "name": "4df0b1dc_dag"
                }
              ],
              "description": "",
              "message_list": [],
              "uuid": "04009b2b-06c0-40a0-8487-83ae8091f393",
              "state": "ACTIVE",
              "variable_list": [],
              "main_task_local_reference": {
                "kind": "app_task",
                "name": "4df0b1dc_dag",
                "uuid": "4701f017-3d27-47e2-82ad-0db6529c53ec"
              },
              "name": "96f39da5_runbook"
            },
            "type": "",
            "upgrade_runbook": {},
            "uninstall_runbook": {
              "task_definition_list": [
                {
                  "target_any_local_reference": {
                    "kind": "app_package",
                    "name": "Package1",
                    "uuid": "b17d1c3e-3491-47a4-802b-ea7c2c28bec2"
                  },
                  "retries": "0",
                  "description": "",
                  "type": "DAG",
                  "uuid": "78214179-48e5-44aa-8ad7-221c3cd7bc41",
                  "child_tasks_local_reference_list": [],
                  "state": "ACTIVE",
                  "attrs": {
                    "edges": [],
                    "type": ""
                  },
                  "timeout_secs": "0",
                  "inherit_target": false,
                  "message_list": [],
                  "variable_list": [],
                  "name": "76a6411c_dag"
                }
              ],
              "description": "",
              "message_list": [],
              "uuid": "e49c73c4-b633-4aa5-8ca0-b3ad10c0cdc6",
              "state": "ACTIVE",
              "variable_list": [],
              "main_task_local_reference": {
                "kind": "app_task",
                "name": "76a6411c_dag",
                "uuid": "78214179-48e5-44aa-8ad7-221c3cd7bc41"
              },
              "name": "2994e4d9_runbook"
            }
          },
          "variable_list": [],
          "name": "Package1"
        }
      ]
    },
    "name": "steph-karbon-cluster-create"
  },
  "spec": {
    "description": "Provisions a Karbon K8s cluster and enables worker node addition and removal.",
    "resources": {
      "client_attrs": {
        "1c2a7ea2_deployment": {
          "y": 350,
          "x": 1052
        }
      },
      "service_definition_list": [
        {
          "singleton": false,
          "action_list": [
            {
              "description": "System action for creating an application",
              "type": "system",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=PcGetProjectReference}",
                      "@{kind=app_task; name=PcCheckProjectQuota}",
                      "@{kind=app_task; name=KarbonCreateCluster}",
                      "@{kind=app_task; name=KarbonGetClusterHealth}",
                      "@{kind=app_task; name=KarbonGetClusterDetails}",
                      "@{kind=app_task; name=UpdateVmProject}",
                      "@{kind=app_task; name=SendKubeconfig}"
                    ],
                    "name": "e1584237_dag",
                    "attrs": {
                      "edges": "      ",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "PcGetProjectReference",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220111\n# task_name:    PcGetProjectReference\n# description:  Given a project name, get the project reference metadata section. \n#               This is then meant to be used to update a VM project reference to move \n#               that VM into the project.\n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   project_reference (as json output)\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_name = \"@@{calm_project_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_projects(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of Projects from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of Projects (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/projects/list\"\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"project\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"project\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n\ndef prism_get_project(api_server,username,secret,project_name,project_uuid=None,secure=False):\n    \"\"\"Returns from Prism Central the uuid and details of a given project name.\n       If a project_uuid is specified, it will skip retrieving all vms (faster).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        project_name: Name of the project.\n        project_uuid: Uuid of the project (optional).\n        \n    Returns:\n        A string containing the UUID of the Project (project_uuid) and the json content\n        of the project details (project_details)\n    \"\"\"\n    project_details = {}\n\n    if project_uuid is None:\n        #get the list vms from Prism\n        project_list = prism_get_projects(api_server,username,secret,secure)\n        for project in project_list:\n            if project['spec']['name'] == project_name:\n                project_uuid = project['metadata']['uuid']\n                project_details = project.copy()\n                break\n    else:\n        headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n        }\n        api_server_port = \"9440\"\n        api_server_endpoint = \"/api/nutanix/v3/projects/{0}\".format(project_uuid)\n        url = \"https://{}:{}{}\".format(\n            api_server,\n            api_server_port,\n            api_server_endpoint\n        )\n        method = \"GET\"\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,secure)\n        if resp.ok:\n            project_details = json.loads(resp.content)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n    return project_uuid, project_details\n\n#endregion functions\n\n\n#region main execution\nproject_uuid,project_details = prism_get_project(prism_central_ip,pc_user,pc_password,project_name)\nproject_reference = project_details['metadata']['project_reference']\nprint(\"project_reference={}\".format(json.dumps(project_reference)))\nexit(0)\n#endregion main execution\n",
                      "eval_variables": "project_reference",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "SET_VARIABLE",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "PcCheckProjectQuota",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220111\n# task_name:    PcCheckProjectQuota\n# description:  Given a project name, check the project quota against provided resources. \n#               If there are not enough available resources in the quota, returns a failure code.\n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_reference = json.loads('@@{project_reference}@@')\nmaster_config = \"@@{master_config}@@\"\nworker_node_cpu_count = int(\"@@{worker_node_cpu}@@\")\nworker_node_vram_bytes = int(\"@@{worker_node_memory}@@\")*1024*1024*1024\nworker_node_storage_bytes = (int(\"@@{worker_node_disk_size}@@\")+40)*1024*1024*1024\nworker_node_qty = int(\"@@{worker_node_qty}@@\")\n\n#? master and etcd nodes configuration depends on master_config (Single Master, or Active-Passive/Active-Active)\n#? worker nodes is based on user input and stored in worker_node_cpu, worker_node_memory, worker_node_disk_size, worker_node_qty\n#? for disk size, add +40GB for system disks for each node VM\nif master_config == \"Single Master\":\n    master_node_cpu_count = 2\n    master_node_vram_bytes = 4*1024*1024*1024\n    master_node_storage_bytes = (120+40)*1024*1024*1024\n    master_node_qty = 1\n    etcd_node_cpu_count = 4\n    etcd_node_vram_bytes = 8*1024*1024*1024\n    etcd_node_storage_bytes = (40+40)*1024*1024*1024\n    etcd_node_qty = 1\nelse:\n    master_node_cpu_count = 4\n    master_node_vram_bytes = 4*1024*1024*1024\n    master_node_storage_bytes = (120+40)*1024*1024*1024\n    master_node_qty = 2\n    etcd_node_cpu_count = 4\n    etcd_node_vram_bytes = 8*1024*1024*1024\n    etcd_node_storage_bytes = (40+40)*1024*1024*1024\n    etcd_node_qty = 3\n\n#worker node(s) + master node(s) + etcd node(s) \nrequired_vcpus_count = (int(worker_node_cpu_count) * int(worker_node_qty)) + (master_node_cpu_count * master_node_qty) +  (etcd_node_cpu_count * etcd_node_qty)\nrequired_vram_bytes = (int(worker_node_vram_bytes) * int(worker_node_qty)) + (master_node_vram_bytes * master_node_qty) +  (etcd_node_vram_bytes * etcd_node_qty)\nrequired_storage_bytes = (int(worker_node_storage_bytes) * int(worker_node_qty)) + (master_node_storage_bytes * master_node_qty) +  (etcd_node_storage_bytes * etcd_node_qty)\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_projects(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of Projects from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of Projects (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/projects/list\"\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"project\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"project\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n\ndef prism_get_project(api_server,username,secret,project_name=None,project_uuid=None,secure=False):\n    \"\"\"Returns from Prism Central the uuid and details of a given project name.\n       If a project_uuid is specified, it will skip retrieving all vms (faster).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        project_name: Name of the project.\n        project_uuid: Uuid of the project (optional).\n        \n    Returns:\n        A string containing the UUID of the Project (project_uuid) and the json content\n        of the project details (project_details)\n    \"\"\"\n    project_details = {}\n\n    if project_uuid is None:\n        #get the list vms from Prism\n        project_list = prism_get_projects(api_server,username,secret,secure)\n        for project in project_list:\n            if project['spec']['name'] == project_name:\n                project_uuid = project['metadata']['uuid']\n                project_details = project.copy()\n                break\n    else:\n        headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n        }\n        api_server_port = \"9440\"\n        api_server_endpoint = \"/api/nutanix/v3/projects/{0}\".format(project_uuid)\n        url = \"https://{}:{}{}\".format(\n            api_server,\n            api_server_port,\n            api_server_endpoint\n        )\n        method = \"GET\"\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,secure)\n        if resp.ok:\n            project_details = json.loads(resp.content)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n    return project_uuid, project_details\n\n#endregion functions\n\n\n#region main execution\n\nprint(\"Provisioning request required vCPUs: {}\".format(required_vcpus_count))\nprint(\"Provisioning request required memory GB: {}\".format(required_vram_bytes/1024/1024/1024))\nprint(\"Provisioning request required storage GB: {}\".format(required_storage_bytes/1024/1024/1024))\n\n\n#region get project quotas\nproject_uuid,project_details = prism_get_project(prism_central_ip,pc_user,pc_password,project_uuid=project_reference['uuid'])\n#get resource total allocated quota from the project definition\nproject_cpu_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'VCPUS']\nprint(\"Project vCPU quota: {}\".format(project_cpu_quota[0]))\nproject_memory_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'MEMORY']\nprint(\"Project memory GB quota: {}\".format(int(project_memory_bytes_quota[0])/1024/1024/1024))\nproject_storage_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'STORAGE']\nprint(\"Project storage GB quota: {}\".format(int(project_storage_bytes_quota[0])/1024/1024/1024))\n#endregion get project quotas\n\n#region get project allocated resources\n#retrieve list of project vms and their current resource allocation\n#region api call\nheaders = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n}\napi_server_port = \"9440\"\napi_server_endpoint = \"/api/nutanix/v3/groups\"\nurl = \"https://{}:{}{}\".format(\n    prism_central_ip,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\npayload = {\n    \"entity_type\": \"mh_vm\",\n    \"group_member_count\": 500,\n    \"group_member_offset\": 0,\n    \"group_member_attributes\": [\n        {\n            \"attribute\": \"memory_size_bytes\"\n        },\n        {\n            \"attribute\": \"capacity_bytes\"\n        },\n        {\n            \"attribute\": \"num_vcpus\"\n        },\n        {\n            \"attribute\": \"project_reference\"\n        },\n        {\n            \"attribute\": \"project_name\"\n        }\n    ],\n    \"query_name\": \"prism:EBQueryModel\",\n    \"availability_zone_scope\": \"GLOBAL\",\n    \"filter_criteria\": \"(platform_type!=aws,platform_type==[no_val]);project_reference=in={}\".format(project_uuid)\n}\nprint(\"Making a {} API call to {}\".format(method, url))\nr = process_request(url,method,pc_user,pc_password,headers,payload)\n#endregion api call\n\n#compute total current resource allocation\nresp = json.loads(r.content)\n\n\nproject_cpu_allocated = 0\nproject_memory_bytes_allocated = 0\nproject_storage_bytes_allocated = 0\n\nif int(resp['filtered_entity_count']) > 0:\n    entities=[entities for entities in resp['group_results'][0]['entity_results']]\n    vm_data = [data['data'] for data in entities]\n\n    for vm in vm_data:\n        for values in vm:\n            if values['name'] == 'num_vcpus':\n                for value in values['values']:\n                    project_cpu_allocated = project_cpu_allocated + int(value['values'][0])\n            elif values['name'] == 'memory_size_bytes':\n                    for value in values['values']:\n                        project_memory_bytes_allocated = project_memory_bytes_allocated + int(value['values'][0])\n            elif values['name'] == 'capacity_bytes':\n                    for value in values['values']:\n                        project_storage_bytes_allocated = project_storage_bytes_allocated + int(value['values'][0])\n                \n    print(\"Project allocated vCPUs: {}\".format(project_cpu_allocated))\n    print(\"Project allocated memory GB: {}\".format(project_memory_bytes_allocated/1024/1024/1024))\n    print(\"Project allocated storage GB: {}\".format(project_storage_bytes_allocated/1024/1024/1024))\nelse:\n    print(\"Project allocated vCPUs: 0\")\n    print(\"Project allocated memory GB: 0\")\n    print(\"Project allocated storage GB: 0\")\n#endregion get project allocated resources\n\n#region figure out if request complies with quotas\n#compute resources available in the project (quota - allocated)\nproject_available_vcpus = int(project_cpu_quota[0]) - project_cpu_allocated\nprint(\"Project available vCPUs: {}\".format(project_available_vcpus))\nproject_available_memory_bytes = int(project_memory_bytes_quota[0]) - project_memory_bytes_allocated\nprint(\"Project available memory bytes: {}\".format(project_available_memory_bytes))\nproject_available_storage_bytes = int(project_storage_bytes_quota[0]) - project_storage_bytes_allocated\nprint(\"Project available storage bytes: {}\".format(project_available_storage_bytes))\n\n#determine if there are enough resource available to process the request\nif (project_available_vcpus - required_vcpus_count) <= 0:\n    print(\"There aren't enough resources left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_memory_bytes - required_vram_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_storage_bytes - required_storage_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelse:\n    print(\"Project resources quota can accomodate this request.\")\n    exit(0)\n#endregion figure out if request complies with quotas\n\n#endregion main execution\n",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonCreateCluster",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonCreateCluster\n# description:  Deploys a Karbon K8s cluster. Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   create_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\nstorage_class_user = \"@@{storage_class_user.username}@@\"\nstorage_class_user_password = \"@@{storage_class_user.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\n\nworker_node_memory = 1024 * int(\"@@{worker_node_memory}@@\")\nworker_node_disk = 1024 * int(\"@@{worker_node_disk_size}@@\")\nworker_node_cpu = int(\"@@{worker_node_cpu}@@\")\nworker_node_qty = int(\"@@{worker_node_qty}@@\")\n\ncluster_name = \"@@{cluster_name}@@\"\nworker_node_pool = \"@@{cluster_name}@@\" + \"-worker-node-pool\"\nmaster_node_pool = \"@@{cluster_name}@@\" + \"-master-node-pool\"\netcd_node_pool = \"@@{cluster_name}@@\" + \"-etcd-node-pool\"\nfile_system = \"ext4\"\nstorage_container_name = \"@@{storage_container_name}@@\"\nk8s_version = \"@@{k8s_version}@@\"\nimage_name = \"@@{image_name}@@\"\nmaster_config = \"@@{master_config}@@\"\n\npe_cluster_uuid = \"@@{pe_cluster_uuid}@@\"\nsubnet_uuid = \"@@{subnet_uuid}@@\"\n\npod_cidr_range = \"@@{pod_cidr_range}@@\"\nservice_cidr_range = \"@@{service_cidr_range}@@\"\nk8s_cni = \"@@{k8s_cni}@@\"\ncalico_cidr = \"@@{calico_cidr}@@\"\nmaster_vip = \"@@{master_vip}@@\"\nmaster_vip2 = \"@@{master_vip2}@@\"\nexternal_lb = \"@@{external_lb}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters\".format(prism_central_ip)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'POST'\n#initial payload\npayload = {\n  \"cni_config\": {\n    \"node_cidr_mask_size\": 24,\n    \"pod_ipv4_cidr\": pod_cidr_range,\n    \"service_ipv4_cidr\": service_cidr_range\n  },\n  \"etcd_config\": {\n   \n  },\n  \"masters_config\": {\n    \n  },\n  \"metadata\": {\n    \"api_version\": \"v1.0.0\"\n  },\n  \"name\": cluster_name,\n  \"storage_class_config\": {\n    \"default_storage_class\": True,\n    \"name\": \"default-storageclass\",\n    \"reclaim_policy\": \"Delete\",\n    \"volumes_config\": {\n      \"file_system\": file_system,\n      \"flash_mode\": False,\n      \"password\": storage_class_user_password,\n      \"prism_element_cluster_uuid\": pe_cluster_uuid,\n      \"storage_container\": storage_container_name,\n      \"username\": storage_class_user\n    }\n  },\n  \"version\": k8s_version,\n  \"workers_config\": {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": worker_node_cpu,\n        \"disk_mib\": worker_node_disk,\n        \"memory_mib\": worker_node_memory,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": worker_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": worker_node_qty\n    }]\n  }\n}\n#adding cni specific configuration\nif (k8s_cni == \"Flannel\"):\n  print (\"Configuring Flannel CNI\")\n  payload['cni_config']['flannel_config'] = {\n    \"ip_pool_configs\": [{\n      \"cidr\": pod_cidr_range\n    }]   \n  }\nelse:\n  print (\"Configuring Calico CNI\")\n  payload['cni_config']['calico_config'] = {\n    \"ip_pool_configs\": [{\n      \"cidr\": calico_cidr\n    }]   \n  }\n#variations for master/etcd pools and lb configuration\nif (master_config == \"Single Master\"):\n  print (\"Configuring Single Master\")\n  master_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 2,\n        \"disk_mib\": 122880,\n        \"memory_mib\": 4096,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": master_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 1\n    }],\n    \"single_master_config\": { \n      \"external_ipv4_address\": master_vip\n    }\n  }\n  payload['masters_config'] = master_pool  \n  etcd_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 40960,\n        \"memory_mib\": 8192,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": etcd_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 1\n    }]\n  }\n  payload['etcd_config'] = etcd_pool\nelif (master_config == \"Active-Passive\"):\n  print (\"Configuring Active-Passive Master\")\n  master_pool = { \n    \"active_passive_config\": {\n      \"external_ipv4_address\": master_vip\n    },\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 122880,\n        \"memory_mib\": 4096,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": master_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 2\n    }]\n  }\n  payload['masters_config'] = master_pool\n  etcd_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 40960,\n        \"memory_mib\": 8192,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": etcd_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 3\n    }]\n  }\n  payload['etcd_config'] = etcd_pool\nelse:\n  print (\"Configuring Active-Active LoadBalancer Master\")\n  master_pool = {\n    \"external_lb_config\": {\n      \"external_ipv4_address\": external_lb,\n      \"master_nodes_config\": [\n      {\n        \"ipv4_address\": master_vip,\n        \"node_pool_name\": cluster_name\n      },\n      {\n        \"ipv4_address\": master_vip2,\n        \"node_pool_name\": cluster_name\n      }\n    ]},\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 122880,\n        \"memory_mib\": 4096,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": master_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 2\n    }]\n  }\n  payload['masters_config'] = master_pool\n  etcd_pool = {\n    \"node_pools\": [\n    {\n      \"ahv_config\": {\n        \"cpu\": 4,\n        \"disk_mib\": 40960,\n        \"memory_mib\": 8192,\n        \"network_uuid\": subnet_uuid,\n        \"prism_element_cluster_uuid\": pe_cluster_uuid\n      },\n      \"name\": etcd_node_pool,\n      \"node_os_version\": image_name,\n      \"num_instances\": 3\n    }]  \n  }\n  payload['etcd_config'] = etcd_pool\n#endregion prepare the api call\n\n\n#region make the api call\n#print(json.dumps(payload))\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to create cluster was successful\")\nprint (json.loads(resp.content))\ncreate_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(create_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,create_task_uuid)\n\nexit(0)\n#endregion make the api call\n",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonGetClusterHealth",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220106\n# task_name:    KarbonGetClusterHealth\n# description:  Retrieves health status for a Karbon managed K8s cluster. \n#               Loops until health status can be retrieved or times out after 20 minutes.\n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n\n#region other variables\ntime_out = 20\n#endregion other variables\n\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters/{}/health\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\ncount = 0\nwhile(count < time_out):\n    print(\"Making a GET request to {}\".format(url))\n    resp = requests.get(url, headers=headers, auth=(pc_user, pc_password), verify=False)\n    if resp.ok:\n        print (\"Successfully retrieved health status for the cluster\")\n        print(json.loads(resp.content))\n        exit(0)\n    elif (resp.status_code == 412):\n        print (\"Cluster Health: K8s cluster deployment not ready.  Sleeping for 60 seconds\")\n        count = count + 1\n        sleep(60)\n    else:\n        print (\"Could not retrieve the cluster health status\")\n        print(json.loads(resp.content))\n        exit(1)\n\nprint (\"Error: Operation Timeout after 20 mins\")\nexit(1)\n#endregion make the api call",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonGetClusterDetails",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220106\n# task_name:    KarbonGetClusterDetails\n# description:  Retrieves configuration information for a Karbon managed K8s cluster. \n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   kubeapi_server_ipv4_address,k8s_version,karbon_cluster_uuid,node_cidr_mask_size,pod_ipv4_cidr,service_ipv4_cidr\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters/{}\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nprint(\"Making a GET request to {}\".format(url))\nresp = process_request(url, method, pc_user, pc_password, headers)\n    \nprint (\"Successfully retrieved health status for the cluster\")\nprint(json.loads(resp.content))\n\n#* output vars defined here\nkubeapi_server_ipv4_address = resp.json()['kubeapi_server_ipv4_address']\nprint (\"kubeapi_server_ipv4_address={}\".format(kubeapi_server_ipv4_address))\nk8s_version = resp.json()['version']\nprint (\"k8s_version={}\".format(k8s_version))\nkarbon_cluster_uuid = resp.json()['uuid']\nprint (\"karbon_cluster_uuid={}\".format(karbon_cluster_uuid))\nnode_cidr_mask_size = resp.json()['cni_config']['node_cidr_mask_size']\nprint (\"node_cidr_mask_size={}\".format(node_cidr_mask_size))\npod_ipv4_cidr = resp.json()['cni_config']['pod_ipv4_cidr']\nprint (\"pod_ipv4_cidr={}\".format(pod_ipv4_cidr))\nservice_ipv4_cidr = resp.json()['cni_config']['service_ipv4_cidr']\nprint (\"service_ipv4_cidr={}\".format(service_ipv4_cidr))\n\nexit(0)\n#endregion make the api call",
                      "eval_variables": "kubeapi_server_ipv4_address cluster_k8s_version karbon_cluster_uuid",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "SET_VARIABLE",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "UpdateVmProject",
                    "attrs": {
                      "type": "CALL_RUNBOOK",
                      "inarg_list": "",
                      "runbook_reference": "@{kind=app_runbook; name=1fece5ec_runbook}"
                    },
                    "timeout_secs": "0",
                    "type": "CALL_RUNBOOK",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "SendKubeconfig",
                    "attrs": {
                      "type": "CALL_RUNBOOK",
                      "inarg_list": "",
                      "runbook_reference": "@{kind=app_runbook; name=55bdcacb_runbook}"
                    },
                    "timeout_secs": "0",
                    "type": "CALL_RUNBOOK",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "82d0a3f5_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "e1584237_dag"
                },
                "variable_list": []
              },
              "name": "action_create"
            },
            {
              "description": "System action for deleting an application. Deletes created VMs as well",
              "type": "system",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonDeleteCluster}"
                    ],
                    "name": "d27d7cd9_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonDeleteCluster",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonDeleteCluster\n# description:  Deletes a Karbon K8s cluster. Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   delete_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                return task_status_details\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters/{}\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'DELETE'\n#initial payload\npayload = {}\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to delete cluster was successful\")\nprint(json.loads(resp.content))\ndelete_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(delete_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,delete_task_uuid)\n\nexit(0)\n#endregion make the api call",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "2cb579b6_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "d27d7cd9_dag"
                },
                "variable_list": []
              },
              "name": "action_delete"
            },
            {
              "description": "System action for starting an application",
              "type": "system",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "21fd9350_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "60814c0f_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "21fd9350_dag"
                },
                "variable_list": []
              },
              "name": "action_start"
            },
            {
              "description": "System action for stopping an application",
              "type": "system",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "8eda2a42_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "46f8c648_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "8eda2a42_dag"
                },
                "variable_list": []
              },
              "name": "action_stop"
            },
            {
              "description": "System action for restarting an application",
              "type": "system",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "8703dd38_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "91fdabc1_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "8703dd38_dag"
                },
                "variable_list": []
              },
              "name": "action_restart"
            },
            {
              "description": "",
              "type": "user",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonGetKubeconfig}",
                      "@{kind=app_task; name=SendMail}"
                    ],
                    "name": "a1aa7936_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonGetKubeconfig",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220106\n# task_name:    KarbonGetKubeConfig\n# description:  Retrieves kubeconfig for the given Karbon cluster. \n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   kubeconfig\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1/k8s/clusters/{}/kubeconfig\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers)\n#* output vars defined here\nkubeconfig = resp.json()['kube_config']\n\nencodedBytes = base64.b64encode(kubeconfig.encode(\"utf-8\"))\nencodedStr = str(encodedBytes)\nprint (\"kubeconfig={}\".format(encodedStr))\n\nexit(0)\n#endregion make the api call",
                      "eval_variables": "kubeconfig",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "SET_VARIABLE",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "SendMail",
                    "attrs": {
                      "exit_status": "",
                      "script": "#!/bin/bash\n\n# region headers\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1.0/20210504 - cita-starter version\n# task_name:    SendMail\n# description:  sends an email notification to the Calm user including kubeconfig.               \n# output vars:  none\n# dependencies: none\n# endregion\n\nFrom=@@{email_sender}@@\nTo=@@{requester_email}@@\nSubject=\"Your Kubernetes kubeconfig\"\nAttachment=\"/tmp/@@{cluster_name}@@-kubeconfig\"\n\n#tee ${Attachment}\necho \"@@{kubeconfig}@@\" | base64 --decode > ${Attachment}\ngzip -f ${Attachment}\n\necho \"\nfrom email.message import EmailMessage\nfrom email.mime.multipart import MIMEMultipart\nimport smtplib\nimport os\nfrom email.mime.base import MIMEBase\nfrom email.mime.text import MIMEText\nfrom email import encoders\n\nserver = smtplib.SMTP(\"\\\"@@{smtp_server}@@\\\"\", 25)\n\nmsg = MIMEMultipart()\nBody = MIMEText('Hello,\\n\\nYou have requested a kubernetes cluster which was successfully deployed with version @@{cluster_k8s_version}@@.\\n\\nYou can connect to it using the following information:\\n\\tService type: Kubernetes Cluster\\n\\tK8s ip address: @@{kubeapi_server_ipv4_address}@@\\n\\tK8s cluster name: @@{cluster_name}@@\\n\\nYou can use the attached kubeconfig or the following kubectl plugin to log into your k8s cluster: https://github.com/nutanix/kubectl-karbon\\n\\nNote that the Prism Central IP address is @@{prism_central_ip}@@\\n\\nRegards,\\n\\nYour IT Team')\nmsg['Subject'] = '${Subject}'\nmsg['From'] = '${From}'\nmsg['To'] = '${To}'\nmsg.attach(Body)\n\npart = MIMEBase('application', 'octet-stream')\npart.set_payload(open('${Attachment}.gz', 'rb').read())\nencoders.encode_base64(part)\npart.add_header('Content-Disposition', 'attachment; filename=${Attachment}.gz')\nmsg.attach(part)\n\nserver.sendmail(msg['From'], [msg['To']], msg.as_string())\" | tee  ~/send_notification\n\necho \"Sending user notification\"\n\npython3 ~/send_notification\n\nrm ~/send_notification\nrm \"${Attachment}.gz\"",
                      "script_type": "sh",
                      "type": "",
                      "command_line_args": "",
                      "login_credential_local_reference": "@{kind=app_credential; name=linux}"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "55bdcacb_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "a1aa7936_dag"
                },
                "variable_list": []
              },
              "name": "SendKubeconfig"
            },
            {
              "description": "",
              "type": "user",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonGetNodePoolsVmHostnames}",
                      "@{kind=app_task; name=PcUpdateVmProject}"
                    ],
                    "name": "8d908151_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonGetNodePoolsVmHostnames",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonGetNodePoolsVmHostnames\n# description:  Given a Karbon cluster name, get all the vm node hostnames from all existing pools. \n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   k8s_cluster_node_vms\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1-alpha.1/k8s/clusters/{}/node-pools\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#initial payload\npayload = {}\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\n\ncontents = json.loads(resp.content)\nk8s_cluster_nodes = [item.get('nodes') for item in contents]\n\nk8s_cluster_node_vms=[]\nfor list in k8s_cluster_nodes:\n    for item in list:\n        k8s_cluster_node_vms.append(item['hostname'])\n\nprint (\"k8s_cluster_node_vms={}\".format(k8s_cluster_node_vms))\n\nexit(0)\n#endregion make the api call\n",
                      "eval_variables": "k8s_cluster_node_vms",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "SET_VARIABLE",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "PcUpdateVmProject",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    PcUpdateVmProject\n# description:  Given a list of vms and a project reference, update all those vms project with the new project reference.\n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_reference = json.loads('@@{project_reference}@@')\nvm_list = @@{k8s_cluster_node_vms}@@\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_vms(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of VMs from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of VMs (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/vms/list\"\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"vm\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"vm\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n#endregion functions\n\n#region main processing\n#* get all vms\nvms = prism_get_vms(prism_central_ip,pc_user,pc_password)\n\n#*foreach given vm in the list\nfor vm in vm_list:\n    #* figure out spec and metadata payload for that vm\n    for vm_object in vms:\n        if vm_object['spec']['name'] == vm:\n            vm_uuid = vm_object['metadata']['uuid']\n            vm_details = vm_object.copy()\n            break\n    vm_details.pop('status')\n    del vm_details['metadata']['entity_version']\n    #print(\"before: {}\".format(vm_details))\n    #* update project reference\n    if vm_details['metadata']['project_reference']['name'] != project_reference['name']:\n        vm_details['metadata']['project_reference'] = project_reference\n        print(\"updated metadata section: {}\".format(json.dumps(vm_details['metadata'])))\n        print(\"vm_uuid: {}\".format(vm_uuid))\n        \n        #* update vm with put\n        #region prepare the api call\n        url = \"https://{}:9440/api/nutanix/v3/vms/{}\".format(prism_central_ip,vm_uuid)\n        headers = {'Content-Type': 'application/json', 'Accept': 'application/json'}\n        method = 'PUT'\n        #initial payload\n        payload = vm_details\n        #print(\"payload: {}\".format(json.dumps(payload)))\n        #endregion prepare the api call\n        #region make the api call\n        print(\"Making a {} API call to {}\".format(method, url))\n        resp = process_request(url, method, pc_user, pc_password, headers, payload)\n        print (\"Updated virtual machine {} with project {}\".format(vm_details['spec']['name'],project_reference['name']))\n        print(json.loads(resp.content))\n        #endregion make the api call\n    else:\n        print(\"Project for vm {} is already {}. Skipping.\".format(vm_details['spec']['name'],project_reference['name']))\n\nexit(0)\n\n\n#endregion main processing",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "1fece5ec_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "8d908151_dag"
                },
                "variable_list": []
              },
              "name": "UpdateVmProject"
            }
          ],
          "depends_on_list": [],
          "name": "ManagementService",
          "port_list": [],
          "tier": "",
          "variable_list": [
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "kubeapi_server_ipv4_address",
              "value": "",
              "label": "Kubernetes Management IP",
              "attrs": {
                "type": ""
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "cluster_k8s_version",
              "value": "",
              "label": "",
              "attrs": {
                "type": ""
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "SECRET",
              "name": "kubeconfig",
              "value": "",
              "label": "",
              "attrs": {
                "is_secret_modified": false,
                "secret_reference": {},
                "type": "SECRET"
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "project_reference",
              "value": "",
              "label": "",
              "attrs": {
                "type": ""
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "k8s_cluster_node_vms",
              "value": "",
              "label": "",
              "attrs": {
                "type": ""
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "karbon_cluster_uuid",
              "value": "",
              "label": "",
              "attrs": {
                "type": ""
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "image_uuid",
              "value": "",
              "label": "",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            }
          ],
          "description": ""
        }
      ],
      "substrate_definition_list": [
        {
          "description": "",
          "action_list": [],
          "type": "EXISTING_VM",
          "name": "ManagementLinuxVM",
          "readiness_probe": {
            "connection_type": "SSH",
            "retries": "5",
            "connection_protocol": "",
            "connection_port": 22,
            "address": "@@{ip_address}@@",
            "delay_secs": "60",
            "disable_readiness_probe": false,
            "login_credential_local_reference": {
              "kind": "app_credential",
              "name": "linux"
            }
          },
          "os_type": "Linux",
          "create_spec": {
            "type": "PROVISION_EXISTING_MACHINE",
            "address": "10.48.111.42"
          },
          "variable_list": []
        }
      ],
      "endpoint_definition_list": [],
      "credential_definition_list": [
        {
          "username": "stephane.bourdeaud@emeagso.lab",
          "description": "",
          "type": "PASSWORD",
          "secret": {
            "attrs": {
              "is_secret_modified": false,
              "secret_reference": {}
            }
          },
          "name": "prism_central",
          "cred_class": "static"
        },
        {
          "username": "stephane.bourdeaud@emeagso.lab",
          "description": "",
          "type": "PASSWORD",
          "secret": {
            "attrs": {
              "is_secret_modified": false,
              "secret_reference": {}
            }
          },
          "name": "storage_class_user",
          "cred_class": "static"
        },
        {
          "username": "centos",
          "description": "",
          "type": "KEY",
          "secret": {
            "attrs": {
              "is_secret_modified": false,
              "secret_reference": {}
            }
          },
          "name": "linux",
          "cred_class": "static"
        }
      ],
      "package_definition_list": [
        {
          "description": "",
          "action_list": [],
          "type": "DEB",
          "service_local_reference_list": [
            {
              "kind": "app_service",
              "name": "ManagementService"
            }
          ],
          "name": "Package1",
          "version": "",
          "options": {
            "install_runbook": {
              "task_definition_list": [
                {
                  "target_any_local_reference": {
                    "kind": "app_package",
                    "name": "Package1"
                  },
                  "retries": "0",
                  "description": "",
                  "inherit_target": false,
                  "child_tasks_local_reference_list": [],
                  "name": "4df0b1dc_dag",
                  "attrs": {
                    "edges": [],
                    "type": ""
                  },
                  "timeout_secs": "0",
                  "type": "DAG",
                  "variable_list": []
                }
              ],
              "description": "",
              "name": "96f39da5_runbook",
              "main_task_local_reference": {
                "kind": "app_task",
                "name": "4df0b1dc_dag"
              },
              "variable_list": []
            },
            "type": "",
            "uninstall_runbook": {
              "task_definition_list": [
                {
                  "target_any_local_reference": {
                    "kind": "app_package",
                    "name": "Package1"
                  },
                  "retries": "0",
                  "description": "",
                  "inherit_target": false,
                  "child_tasks_local_reference_list": [],
                  "name": "76a6411c_dag",
                  "attrs": {
                    "edges": [],
                    "type": ""
                  },
                  "timeout_secs": "0",
                  "type": "DAG",
                  "variable_list": []
                }
              ],
              "description": "",
              "name": "2994e4d9_runbook",
              "main_task_local_reference": {
                "kind": "app_task",
                "name": "76a6411c_dag"
              },
              "variable_list": []
            },
            "upgrade_runbook": {}
          },
          "variable_list": []
        }
      ],
      "app_profile_list": [
        {
          "deployment_create_list": [
            {
              "type": "GREENFIELD",
              "action_list": [],
              "name": "1c2a7ea2_deployment",
              "min_replicas": "1",
              "default_replicas": "1",
              "depends_on_list": [],
              "published_service_local_reference_list": [],
              "max_replicas": "1",
              "package_local_reference_list": [
                {
                  "kind": "app_package",
                  "name": "Package1"
                }
              ],
              "substrate_local_reference": {
                "kind": "app_substrate",
                "name": "ManagementLinuxVM"
              },
              "variable_list": [],
              "description": ""
            }
          ],
          "environment_reference_list": [],
          "application_url": "",
          "description": "",
          "action_list": [
            {
              "description": "",
              "type": "user",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=PcCheckProjectQuota}",
                      "@{kind=app_task; name=KarbonAddWorkerNode}",
                      "@{kind=app_task; name=UpdateVmProject}"
                    ],
                    "name": "6f43296c_dag",
                    "attrs": {
                      "edges": " ",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "PcCheckProjectQuota",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220111\n# task_name:    PcCheckProjectQuota\n# description:  Given a project name, check the project quota against provided resources. \n#               If there are not enough available resources in the quota, returns a failure code.\n#               Using PCv3 API: https://www.nutanix.dev/api_references/prism-central-v3/#/ZG9jOjQ1Mg-nutanix-intentful-api\n# inputvars:    See inputvars region below\n# outputvars:   none\n\nimport requests\n\n\n#region inputvars\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nproject_reference = json.loads('@@{project_reference}@@')\nworker_node_cpu_count = int(\"@@{worker_node_cpu}@@\")\nworker_node_vram_bytes = int(\"@@{worker_node_memory}@@\")*1024*1024*1024\nworker_node_storage_bytes = (int(\"@@{worker_node_disk_size}@@\")+40)*1024*1024*1024\nworker_node_qty = int(\"@@{add_worker_node_count}@@\")\n\n\n\n#worker node(s) + master node(s) + etcd node(s) \nrequired_vcpus_count = (int(worker_node_cpu_count) * int(worker_node_qty))\nrequired_vram_bytes = (int(worker_node_vram_bytes) * int(worker_node_qty))\nrequired_storage_bytes = (int(worker_node_storage_bytes) * int(worker_node_qty))\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_projects(api_server,username,secret,secure=False):\n    \"\"\"Retrieve the list of Projects from Prism Central.\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        \n    Returns:\n        A list of Projects (entities part of the json response).\n    \"\"\"\n    entities = []\n    #region prepare the api call\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/projects/list\"\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"POST\"\n    length = 200\n\n    # Compose the json payload\n    payload = {\n        \"kind\": \"project\",\n        \"offset\": 0,\n        \"length\": length\n    }\n    #endregion\n    while True:\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,payload,secure)\n\n        # deal with the result/response\n        if resp.ok:\n            json_resp = json.loads(resp.content)\n            entities.extend(json_resp['entities'])\n            key = 'length'\n            if key in json_resp['metadata']:\n                if json_resp['metadata']['length'] == length:\n                    print(\"Processing results from {} to {} out of {}\".format(\n                        json_resp['metadata']['offset'], \n                        json_resp['metadata']['length']+json_resp['metadata']['offset'],\n                        json_resp['metadata']['total_matches']))\n                    payload = {\n                        \"kind\": \"project\",\n                        \"offset\": json_resp['metadata']['length'] + json_resp['metadata']['offset'] + 1,\n                        \"length\": length\n                    }\n                else:\n                    return entities\n                    break\n            else:\n                return entities\n                break\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n\n\ndef prism_get_project(api_server,username,secret,project_name=None,project_uuid=None,secure=False):\n    \"\"\"Returns from Prism Central the uuid and details of a given project name.\n       If a project_uuid is specified, it will skip retrieving all vms (faster).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        project_name: Name of the project.\n        project_uuid: Uuid of the project (optional).\n        \n    Returns:\n        A string containing the UUID of the Project (project_uuid) and the json content\n        of the project details (project_details)\n    \"\"\"\n    project_details = {}\n\n    if project_uuid is None:\n        #get the list vms from Prism\n        project_list = prism_get_projects(api_server,username,secret,secure)\n        for project in project_list:\n            if project['spec']['name'] == project_name:\n                project_uuid = project['metadata']['uuid']\n                project_details = project.copy()\n                break\n    else:\n        headers = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n        }\n        api_server_port = \"9440\"\n        api_server_endpoint = \"/api/nutanix/v3/projects/{0}\".format(project_uuid)\n        url = \"https://{}:{}{}\".format(\n            api_server,\n            api_server_port,\n            api_server_endpoint\n        )\n        method = \"GET\"\n        print(\"Making a {} API call to {} with secure set to {}\".format(method, url, secure))\n        resp = process_request(url,method,username,secret,headers,secure)\n        if resp.ok:\n            project_details = json.loads(resp.content)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            raise\n    return project_uuid, project_details\n\n#endregion functions\n\n\n#region main execution\n\nprint(\"Provisioning request required vCPUs: {}\".format(required_vcpus_count))\nprint(\"Provisioning request required memory GB: {}\".format(required_vram_bytes/1024/1024/1024))\nprint(\"Provisioning request required storage GB: {}\".format(required_storage_bytes/1024/1024/1024))\n\n\n#region get project quotas\nproject_uuid,project_details = prism_get_project(prism_central_ip,pc_user,pc_password,project_uuid=project_reference['uuid'])\n#get resource total allocated quota from the project definition\nproject_cpu_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'VCPUS']\nprint(\"Project vCPU quota: {}\".format(project_cpu_quota[0]))\nproject_memory_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'MEMORY']\nprint(\"Project memory GB quota: {}\".format(int(project_memory_bytes_quota[0])/1024/1024/1024))\nproject_storage_bytes_quota = [limit['limit'] for limit in project_details['spec']['resources']['resource_domain']['resources'] if limit['resource_type'] == 'STORAGE']\nprint(\"Project storage GB quota: {}\".format(int(project_storage_bytes_quota[0])/1024/1024/1024))\n#endregion get project quotas\n\n#region get project allocated resources\n#retrieve list of project vms and their current resource allocation\n#region api call\nheaders = {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json'\n}\napi_server_port = \"9440\"\napi_server_endpoint = \"/api/nutanix/v3/groups\"\nurl = \"https://{}:{}{}\".format(\n    prism_central_ip,\n    api_server_port,\n    api_server_endpoint\n)\nmethod = \"POST\"\npayload = {\n    \"entity_type\": \"mh_vm\",\n    \"group_member_count\": 500,\n    \"group_member_offset\": 0,\n    \"group_member_attributes\": [\n        {\n            \"attribute\": \"memory_size_bytes\"\n        },\n        {\n            \"attribute\": \"capacity_bytes\"\n        },\n        {\n            \"attribute\": \"num_vcpus\"\n        },\n        {\n            \"attribute\": \"project_reference\"\n        },\n        {\n            \"attribute\": \"project_name\"\n        }\n    ],\n    \"query_name\": \"prism:EBQueryModel\",\n    \"availability_zone_scope\": \"GLOBAL\",\n    \"filter_criteria\": \"(platform_type!=aws,platform_type==[no_val]);project_reference=in={}\".format(project_uuid)\n}\nprint(\"Making a {} API call to {}\".format(method, url))\nr = process_request(url,method,pc_user,pc_password,headers,payload)\n#endregion api call\n\n#compute total current resource allocation\nresp = json.loads(r.content)\n\n\nproject_cpu_allocated = 0\nproject_memory_bytes_allocated = 0\nproject_storage_bytes_allocated = 0\n\nif int(resp['filtered_entity_count']) > 0:\n    entities=[entities for entities in resp['group_results'][0]['entity_results']]\n    vm_data = [data['data'] for data in entities]\n\n    for vm in vm_data:\n        for values in vm:\n            if values['name'] == 'num_vcpus':\n                for value in values['values']:\n                    project_cpu_allocated = project_cpu_allocated + int(value['values'][0])\n            elif values['name'] == 'memory_size_bytes':\n                    for value in values['values']:\n                        project_memory_bytes_allocated = project_memory_bytes_allocated + int(value['values'][0])\n            elif values['name'] == 'capacity_bytes':\n                    for value in values['values']:\n                        project_storage_bytes_allocated = project_storage_bytes_allocated + int(value['values'][0])\n                \n    print(\"Project allocated vCPUs: {}\".format(project_cpu_allocated))\n    print(\"Project allocated memory GB: {}\".format(project_memory_bytes_allocated/1024/1024/1024))\n    print(\"Project allocated storage GB: {}\".format(project_storage_bytes_allocated/1024/1024/1024))\nelse:\n    print(\"Project allocated vCPUs: 0\")\n    print(\"Project allocated memory GB: 0\")\n    print(\"Project allocated storage GB: 0\")\n#endregion get project allocated resources\n\n#region figure out if request complies with quotas\n#compute resources available in the project (quota - allocated)\nproject_available_vcpus = int(project_cpu_quota[0]) - project_cpu_allocated\nprint(\"Project available vCPUs: {}\".format(project_available_vcpus))\nproject_available_memory_bytes = int(project_memory_bytes_quota[0]) - project_memory_bytes_allocated\nprint(\"Project available memory bytes: {}\".format(project_available_memory_bytes))\nproject_available_storage_bytes = int(project_storage_bytes_quota[0]) - project_storage_bytes_allocated\nprint(\"Project available storage bytes: {}\".format(project_available_storage_bytes))\n\n#determine if there are enough resource available to process the request\nif (project_available_vcpus - required_vcpus_count) <= 0:\n    print(\"There aren't enough resources left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_memory_bytes - required_vram_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelif (project_available_storage_bytes - required_storage_bytes) <= 0:\n    print(\"There aren't enough resources bytes left in the project quota to accomodate this request!\")\n    exit(1)\nelse:\n    print(\"Project resources quota can accomodate this request.\")\n    exit(0)\n#endregion figure out if request complies with quotas\n\n#endregion main execution\n\n",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonAddWorkerNode",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonAddWorkerNode\n# description:  Adds worker node(s) to an existing Karbon managed k8s cluster. Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   add_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nadd_worker_node_count = int(\"@@{add_worker_node_count}@@\")\ncluster_name = \"@@{cluster_name}@@\"\nworker_node_pool = \"@@{cluster_name}@@\" + \"-worker-node-pool\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\npayload = {\n  \"count\": add_worker_node_count\n}\nmethod = 'POST'\nurl = \"https://{}:9440/karbon/v1-alpha.1/k8s/clusters/{}/node-pools/{}/add-nodes\".format(\n    prism_central_ip,\n    cluster_name,\n    worker_node_pool,\n)\n#endregion prepare api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to add Worker Node was successful\")\nprint(json.loads(resp.content))\nadd_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(add_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,add_task_uuid)\n\nexit(0)\n#endregion make api call",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "UpdateVmProject",
                    "attrs": {
                      "type": "CALL_RUNBOOK",
                      "inarg_list": "",
                      "runbook_reference": "@{kind=app_runbook; name=1fece5ec_runbook}"
                    },
                    "timeout_secs": "0",
                    "type": "CALL_RUNBOOK",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "876ef50a_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "6f43296c_dag"
                },
                "variable_list": [
                  {
                    "regex": {
                      "should_validate": false,
                      "value": "^[\\d]*$"
                    },
                    "val_type": "INT",
                    "is_mandatory": false,
                    "description": "",
                    "data_type": "BASE",
                    "type": "LOCAL",
                    "name": "add_worker_node_count",
                    "value": "1",
                    "label": "Nb of worker nodes to add",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    }
                  }
                ]
              },
              "name": "Add Worker Node"
            },
            {
              "description": "",
              "type": "user",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonRemoveWorkerNode}"
                    ],
                    "name": "569dfdac_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonRemoveWorkerNode",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonRemoveWorkerNode\n# description:  Removes worker node(s) from an existing Karbon managed k8s cluster. Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   remove_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nremove_worker_node_count = int(\"@@{remove_worker_node_count}@@\")\ncluster_name = \"@@{cluster_name}@@\"\nworker_node_pool = \"@@{cluster_name}@@\" + \"-worker-node-pool\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=60\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                return task_status_details\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\npayload = {\n  \"count\": remove_worker_node_count\n}\nmethod = 'POST'\nurl = \"https://{}:9440/karbon/v1-alpha.1/k8s/clusters/{}/node-pools/{}/remove-nodes\".format(\n    prism_central_ip,\n    cluster_name,\n    worker_node_pool,\n)\n#endregion prepapre api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Creation of task to remove Worker Node was successful\")\nprint(json.loads(resp.content))\nremove_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(remove_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,remove_task_uuid)\n\nexit(0)\n#endregion make api call",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "bd846b3b_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "569dfdac_dag"
                },
                "variable_list": [
                  {
                    "regex": {
                      "should_validate": false,
                      "value": "^[\\d]*$"
                    },
                    "val_type": "INT",
                    "is_mandatory": false,
                    "description": "",
                    "data_type": "BASE",
                    "type": "LOCAL",
                    "name": "remove_worker_node_count",
                    "value": "1",
                    "label": "Nb of worker nodes to remove",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    }
                  }
                ]
              },
              "name": "Remove Worker Node"
            },
            {
              "description": "",
              "type": "user",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=SendKubeconfig}"
                    ],
                    "name": "548dfee9_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "SendKubeconfig",
                    "attrs": {
                      "type": "CALL_RUNBOOK",
                      "inarg_list": "",
                      "runbook_reference": "@{kind=app_runbook; name=55bdcacb_runbook}"
                    },
                    "timeout_secs": "0",
                    "type": "CALL_RUNBOOK",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "124dab53_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "548dfee9_dag"
                },
                "variable_list": [
                  {
                    "regex": {
                      "should_validate": true,
                      "value": "(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])"
                    },
                    "val_type": "STRING",
                    "is_mandatory": true,
                    "description": "The kubeconfig file will be sent to this email address.",
                    "data_type": "BASE",
                    "type": "LOCAL",
                    "name": "email_address",
                    "value": "stephane.bourdeaud@nutanix.com",
                    "label": "Your email address",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    }
                  }
                ]
              },
              "name": "Get kubeconfig file"
            },
            {
              "description": "",
              "type": "user",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonGetAvailableUpdates}"
                    ],
                    "name": "0b6c6c05_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonGetAvailableUpdates",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonGetK8sUpdates\n# description:  Retrieves list of available upgrade versions for the given cluster name. \n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   k8s_versions and os_versions (as list)\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ncluster_name = \"@@{cluster_name}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/v1-beta.1/k8s/clusters/available-updates\".format(prism_central_ip,cluster_name)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers)\n#* output vars defined here\n#k8s_versions_list = [clusters['ntnx_k8s_releases'] for clusters in resp if clusters['name'] == cluster_name]\n#k8s_versions = [version_number['version'] for version_number in version for version in k8s_versions_list]\n\nk8s_versions = []\nos_versions = []\n\nfor clusters in json.loads(resp.content):\n    #print(\"clusters: {}\".format(clusters))\n    if clusters['name'] == cluster_name:\n        if clusters['ntnx_k8s_releases']:\n            for k8s_version in clusters['ntnx_k8s_releases']:\n                #print(\"versions: {}\".format(versions))\n                k8s_versions.append(k8s_version['version'])\n        if clusters['node_os_images']:\n            for os_version in clusters['node_os_images']:\n                os_versions.append(os_version['version'])\n\n\nprint(\"k8s_versions={}\".format(json.dumps(k8s_versions)))\nprint(\"os_versions={}\".format(json.dumps(os_versions)))\n\nexit(0)\n#endregion make the api call",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "5f14601c_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "0b6c6c05_dag"
                },
                "variable_list": []
              },
              "name": "Get available upgrades"
            },
            {
              "description": "",
              "type": "user",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonUpgradeK8s}"
                    ],
                    "name": "f9ebd532_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonUpgradeK8s",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220113\n# task_name:    KarbonUpgradeK8s\n# description:  Upgrades the target Karbon K8s cluster to the desired version\n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   upgrade_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nkarbon_cluster_uuid = \"@@{karbon_cluster_uuid}@@\"\ncluster_name = \"@@{cluster_name}@@\"\nk8s_version = \"@@{k8s_version}@@\"\ntarget_k8s_version = \"@@{target_k8s_version}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout = 30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\npayload = {\n    \"upgrade_config\": {\n        \"pkg_version\": target_k8s_version\n    },\n    \"cluster_uuid\": karbon_cluster_uuid,\n    \"drain-policy\": \"kAlways\",\n    \"drain-timeout\": \"180s\"\n}\nmethod = 'POST'\nurl = \"https://{}:9440/karbon/acs/k8s/cluster/{}/k8s_upgrade\".format(\n    prism_central_ip,\n    karbon_cluster_uuid\n)\n#endregion prepare api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Upgrading Kubernetes cluster {} from version {} to version {}\".format(cluster_name,k8s_version,target_k8s_version))\nprint(json.loads(resp.content))\nupgrade_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(upgrade_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,upgrade_task_uuid)\n\nexit(0)\n#endregion make api call",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "e63f4359_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "f9ebd532_dag"
                },
                "variable_list": [
                  {
                    "val_type": "STRING",
                    "is_mandatory": true,
                    "description": "You can use the \"Get available upgrades\" action to find out which versions this cluster is eligle for.",
                    "data_type": "BASE",
                    "type": "LOCAL",
                    "name": "target_k8s_version",
                    "value": "1.20.9-0",
                    "label": "Which version of k8s do you want to upgrade to?",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    }
                  }
                ]
              },
              "name": "Upgrade k8s version"
            },
            {
              "description": "",
              "type": "user",
              "critical": false,
              "runbook": {
                "task_definition_list": [
                  {
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [
                      "@{kind=app_task; name=KarbonGetImageUuid}",
                      "@{kind=app_task; name=KarbonUpgradeHosts}"
                    ],
                    "name": "6b4814a0_dag",
                    "attrs": {
                      "edges": "",
                      "type": ""
                    },
                    "timeout_secs": "0",
                    "type": "DAG",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonGetImageUuid",
                    "attrs": {
                      "exit_status": "",
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220107\n# task_name:    KarbonGetImageUuid\n# description:  Gets the uuid of the specified host image version. \n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   image_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\ntarget_image_version = \"@@{target_image_version}@@\"\n#endregion inputvars\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout=10\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n#endregion functions\n\n#region prepare the api call\nurl = \"https://{}:9440/karbon/acs/image/list\".format(prism_central_ip)\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\nmethod = 'GET'\n#endregion prepare the api call\n\n\n#region make the api call\nresp = process_request(url, method, pc_user, pc_password, headers)\n#* output vars defined here\nimages = json.loads(resp.content)\n\nfor image in images:\n    if image['version'] == target_image_version:\n        image_uuid = image['image_uuid']\n        print (\"image_uuid={}\".format(image_uuid))\n        exit(0)\n\nprint (\"Could not find image uuid for image version {}\".format(target_image_version))\nexit(1)\n#endregion make the api call",
                      "eval_variables": "image_uuid",
                      "eval_scope": "local",
                      "type": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "SET_VARIABLE",
                    "variable_list": []
                  },
                  {
                    "target_any_local_reference": {
                      "kind": "app_service",
                      "name": "ManagementService"
                    },
                    "retries": "0",
                    "description": "",
                    "inherit_target": false,
                    "child_tasks_local_reference_list": [],
                    "name": "KarbonUpgradeHosts",
                    "attrs": {
                      "script": "# escript-template v20190611 / stephane.bourdeaud@nutanix.com\n# TODO Fill in this section with your information\n# * author:     stephane.bourdeaud@nutanix.com\n# * version:    v1/20220113\n# task_name:    KarbonUpgradeHosts\n# description:  Upgrades the target Karbon K8s cluster nodes to the desired host image version\n#               Using Karbon API: https://www.nutanix.dev/api_references/karbon/#/ZG9jOjQ1Mg-karbon-api-reference\n# inputvars:    See inputvars region below\n# outputvars:   upgrade_task_uuid\n\nimport requests\n\n\n#region inputvars\n#* credentials\npc_user = \"@@{prism_central.username}@@\"\npc_password = \"@@{prism_central.secret}@@\"\n\n#* input variables\nprism_central_ip = \"@@{prism_central_ip}@@\"\nkarbon_cluster_uuid = \"@@{karbon_cluster_uuid}@@\"\ncluster_name = \"@@{cluster_name}@@\"\nimage_uuid = \"@@{image_uuid}@@\"\ntarget_image_version = \"@@{target_image_version}@@\"\n#endregion inputvars\n\n\n#region functions\n\ndef process_request(url, method, user, password, headers, payload=None, secure=False):\n    if payload is not None:\n        payload = json.dumps(payload)\n    \n    #configuring web request behavior\n    timeout = 30\n    retries = 5\n    sleep_between_retries = 5\n    \n    while retries > 0:\n        try:\n\n            if method == 'POST':\n                    r = requests.post(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'DELETE':\n                r = requests.delete(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'GET':\n                r = requests.get(\n                    url,\n                    headers=headers,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PUT':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n            elif method == 'PATCH':\n                    r = requests.put(\n                    url,\n                    headers=headers,\n                    data=payload,\n                    auth=(user, password),\n                    verify=secure,\n                    timeout=timeout\n                )\n        except requests.exceptions.HTTPError as e:\n            print (\"Http Error!\")\n            print(\"status code: {}\".format(r.status_code))\n            print(\"reason: {}\".format(r.reason))\n            print(\"text: {}\".format(r.text))\n            print(\"elapsed: {}\".format(r.elapsed))\n            print(\"headers: {}\".format(r.headers))\n            if payload is not None:\n                print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(r.content),\n                indent=4\n            ))\n            exit(r.status_code)\n        except requests.exceptions.ConnectionError as e:\n            print (\"Connection Error!\")\n            if retries == 1:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                exit(1)\n            else:\n                print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n            print('Error: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n            exit(1)\n        except requests.exceptions.Timeout as e:\n            print (\"Timeout Error!\")\n            if retries == 1:\n                raise Exception(e)\n            else:\n                print('Error! Code: {c}, Message: {m}'.format(c = type(e).__name__, m = str(e)))\n                sleep(sleep_between_retries)\n                retries -= 1\n                print (\"retries left: {}\".format(retries))\n                continue\n        except requests.exceptions.RequestException as e:\n            print (\"Error!\")\n            exit(r.status_code)\n        break\n    \n    if r.ok:\n        return r\n    if r.status_code == 401:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        exit(r.status_code)\n    elif r.status_code == 500:\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        exit(r.status_code)\n    else:\n        print(\"Request failed!\")\n        print(\"status code: {0}\".format(r.status_code))\n        print(\"reason: {0}\".format(r.reason))\n        print(\"text: {0}\".format(r.text))\n        print(\"raise_for_status: {0}\".format(r.raise_for_status()))\n        print(\"elapsed: {0}\".format(r.elapsed))\n        print(\"headers: {0}\".format(r.headers))\n        if payload is not None:\n            print(\"payload: {0}\".format(payload))\n        print(json.dumps(\n            json.loads(r.content),\n            indent=4\n        ))\n        exit(r.status_code)\n\n\ndef prism_get_task(api_server,username,secret,task_uuid,secure=False):\n    \"\"\"Given a Prism Central task uuid, loop until the task is completed\n    and return the status (success or error).\n\n    Args:\n        api_server: The IP or FQDN of Prism.\n        username: The Prism user name.\n        secret: The Prism user name password.\n        task_uuid: Prism Central task uuid (generally returned by another action \n                   performed on PC).\n        \n    Returns:\n        The task completion status.\n    \"\"\"\n    task_status_details = {}\n    task_status = \"RUNNING\"\n\n    headers = {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n    }\n    api_server_port = \"9440\"\n    api_server_endpoint = \"/api/nutanix/v3/tasks/{0}\".format(task_uuid)\n    url = \"https://{}:{}{}\".format(\n        api_server,\n        api_server_port,\n        api_server_endpoint\n    )\n    method = \"GET\"\n    print(\"Making a {} API call to {}\".format(method, url))\n    \n    while True:\n        resp = process_request(url,method,username,secret,headers,secure)\n        #print(json.loads(resp.content))\n        if resp.ok:\n            task_status_details = json.loads(resp.content)\n            task_status = resp.json()['status']\n            if task_status == \"SUCCEEDED\":\n                print (\"Task has completed successfully\")\n                return task_status_details\n            elif task_status == \"FAILED\":\n                print (\"Task has failed: {}\".format(resp.json()['error_detail']))\n                exit(1)\n            else:\n                print (\"Task status is {} and percentage completion is {}. Current step is {}. Waiting for 30 seconds.\".format(task_status,resp.json()['percentage_complete'],resp.json()['progress_message']))\n                sleep(30)\n        else:\n            print(\"Request failed!\")\n            print(\"status code: {}\".format(resp.status_code))\n            print(\"reason: {}\".format(resp.reason))\n            print(\"text: {}\".format(resp.text))\n            print(\"raise_for_status: {}\".format(resp.raise_for_status()))\n            print(\"elapsed: {}\".format(resp.elapsed))\n            print(\"headers: {}\".format(resp.headers))\n            print(\"payload: {}\".format(payload))\n            print(json.dumps(\n                json.loads(resp.content),\n                indent=4\n            ))\n            exit(resp.status_code)\n\n    return task_status_details\n\n#endregion functions\n\n\n#region prepare api call\nheaders = {'Content-Type': 'application/json', 'Accept': 'application/json'}\npayload = {\n    \"image_uuid\": image_uuid,\n    \"cluster_uuid\": karbon_cluster_uuid,\n    \"drain-policy\": \"kAlways\",\n    \"drain-timeout\": \"180s\"\n}\nmethod = 'POST'\nurl = \"https://{}:9440/karbon/acs/k8s/cluster/{}/upgrade\".format(\n    prism_central_ip,\n    karbon_cluster_uuid\n)\n#endregion prepare api call\n\n\n#region make api call\nresp = process_request(url, method, pc_user, pc_password, headers, payload)\nprint (\"Upgrading Kubernetes cluster {} to host image version {}\".format(cluster_name,target_image_version))\nprint(json.loads(resp.content))\nupgrade_task_uuid = resp.json()['task_uuid']\nprint (\"task_uuid={}\".format(upgrade_task_uuid))\n\nprism_get_task(prism_central_ip,pc_user,pc_password,upgrade_task_uuid)\n\nexit(0)\n#endregion make api call",
                      "type": "",
                      "command_line_args": "",
                      "exit_status": "",
                      "script_type": "static"
                    },
                    "timeout_secs": "0",
                    "type": "EXEC",
                    "variable_list": []
                  }
                ],
                "description": "",
                "name": "501699c7_runbook",
                "main_task_local_reference": {
                  "kind": "app_task",
                  "name": "6b4814a0_dag"
                },
                "variable_list": [
                  {
                    "val_type": "STRING",
                    "is_mandatory": false,
                    "description": "You can use the \"Get available upgrades\" action to find out which host images this cluster is eligible for.",
                    "data_type": "BASE",
                    "type": "LOCAL",
                    "name": "target_image_version",
                    "value": "ntnx-1.1",
                    "label": "Which host image version do you want to upgrade to?",
                    "attrs": {
                      "type": ""
                    },
                    "editables": {
                      "value": true
                    },
                    "is_hidden": false,
                    "options": {
                      "type": "PREDEFINED",
                      "choices": ""
                    }
                  }
                ]
              },
              "name": "Upgrade node host images"
            }
          ],
          "name": "Default",
          "restore_config_list": [],
          "snapshot_config_list": [],
          "patch_list": [],
          "variable_list": [
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "prism_central_ip",
              "value": "127.0.0.1",
              "label": "",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "smtp_server",
              "value": "10.40.64.35",
              "label": "",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "email_sender",
              "value": "stephane.bourdeaud@nutanix.com",
              "label": "",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "UUID of the AHV managed network used to deploy this cluster.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "subnet_uuid",
              "value": "7c19b244-bcc7-4186-9f09-84db45dec57f",
              "label": "",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "UUID of the AHV cluster used to deploy this cluster.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "pe_cluster_uuid",
              "value": "00058163-33b2-4359-0000-0000000167e4",
              "label": "",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": false
              },
              "is_hidden": true,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Name of the storage container used to provision k8s nodes and their vdisks.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "storage_container_name",
              "value": "default-container-92132",
              "label": "",
              "attrs": {
                "type": ""
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Version of the host OS image used to provision k8s nodes by Karbon.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "image_name",
              "value": "ntnx-1.1",
              "label": "",
              "attrs": {
                "type": ""
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "This is the IPv4 CIDR range that will be used for the overlay network used by the pods.\nThe default is 172.20.0.0/16. This can be the same for multiple different k8s clusters if pods from different clusters don't need to talk to each other directly.\nThis is only used if your selected Calico as the CNI.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "calico_cidr",
              "value": "172.20.0.0/16",
              "label": "Calico CIDR Range",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Required for Active-Active setups.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "external_lb",
              "value": "",
              "label": "External Load Balancer IP address",
              "attrs": {
                "type": ""
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Only required for Active-Active setups.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "master_vip2",
              "value": "",
              "label": "Other Kubernetes VIP",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "Only required for Active-Passive and Active-Active setups.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "master_vip",
              "value": "",
              "label": "Kubernetes Cluster VIP",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "This is the IPv4 CIDR range that will be used for the overlay network used by the pods.\nThe default is 172.20.0.0/16. This can be the same for multiple different k8s clusters if pods from different clusters don't need to talk to each other directly.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "pod_cidr_range",
              "value": "172.20.0.0/16",
              "label": "Pod CIDR Range",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(3[0-2]|[1-2][0-9]|[0-9]))$"
              },
              "val_type": "STRING",
              "is_mandatory": false,
              "description": "This is the IPv4 CIDR range that will be used for the service overlay network between the k8s nodes.\nThe default is 172.19.0.0/16. This can be the same for multiple different k8s clusters.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "service_cidr_range",
              "value": "172.19.0.0/16",
              "label": "Service CIDR Range",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": false,
                "value": "^[\\d]*$"
              },
              "val_type": "INT",
              "is_mandatory": true,
              "description": "Quantity of worker nodes in the k8s cluster.\nDefault is the minimum of 1.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "worker_node_qty",
              "value": "1",
              "label": "Qty of Worker Nodes",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": false,
                "value": "^[\\d]*$"
              },
              "val_type": "INT",
              "is_mandatory": true,
              "description": "Size (in GiB) of vDisk for each worker node.\nDefault is a minimum of 120 GiB.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "worker_node_disk_size",
              "value": "120",
              "label": "Worker Nodes vDisk GiB",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": false,
                "value": "^[\\d]*$"
              },
              "val_type": "INT",
              "is_mandatory": true,
              "description": "Quantity (in GiB) of vRAM for each worker node.\nDefault is a minimum of 8 GiB.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "worker_node_memory",
              "value": "8",
              "label": "Worker Nodes vRAM GiB",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": false,
                "value": "^[\\d]*$"
              },
              "val_type": "INT",
              "is_mandatory": true,
              "description": "Number of vCPUs for each worker nodes.\nDefault is a minimum of 8 vCPUs.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "worker_node_cpu",
              "value": "8",
              "label": "Worker Nodes vCPU Qty",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "k8s_cni",
              "value": "Flannel",
              "label": "Kubernetes CNI",
              "attrs": {
                "type": "LOCAL"
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": [
                  "Flannel",
                  "Calico"
                ]
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "Single Master: for non-production environments\nActive-Passive: for production environments without an external load balancer\nActive-Active: for production environments with a pre-configured external load balancer",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "master_config",
              "value": "Single Master",
              "label": "Master node configuration",
              "attrs": {
                "type": "LOCAL"
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": [
                  "Single Master",
                  "Active-Passive",
                  "Active-Active"
                ]
              }
            },
            {
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "k8s_version",
              "value": "1.20.9-0",
              "label": "Kubernetes version",
              "attrs": {
                "type": "LOCAL"
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": [
                  "1.20.9-0",
                  "1.19.13-0",
                  "1.18.20-0",
                  "1.17.13-0"
                ]
              }
            },
            {
              "regex": {
                "should_validate": true,
                "value": "^((?!_).)*$"
              },
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "This is the name that will be displayed in the Karbon cluster manager.  It cannot contain any underscore (_) character.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "cluster_name",
              "value": "steph-karbon-test-cluster",
              "label": "Kubernetes Cluster Name",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            },
            {
              "regex": {
                "should_validate": true,
                "value": "(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])"
              },
              "val_type": "STRING",
              "is_mandatory": true,
              "description": "This will be used to send you information about the provisioned k8s cluster.",
              "data_type": "BASE",
              "type": "LOCAL",
              "name": "requester_email",
              "value": "stephane.bourdeaud@nutanix.com",
              "label": "Your email address",
              "attrs": {
                "type": ""
              },
              "editables": {
                "value": true
              },
              "is_hidden": false,
              "options": {
                "type": "PREDEFINED",
                "choices": []
              }
            }
          ]
        }
      ],
      "published_service_definition_list": [],
      "default_credential_local_reference": {
        "kind": "app_credential",
        "name": "prism_central"
      },
      "type": "USER"
    },
    "name": "steph-karbon-cluster-create"
  },
  "api_version": "3.0",
  "metadata": {
    "last_update_time": "1668775947695926",
    "kind": "blueprint",
    "spec_version": 3,
    "creation_time": "1668775705680057",
    "name": "steph-karbon-cluster-create"
  }
}
